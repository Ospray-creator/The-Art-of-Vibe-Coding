# Глава 16. Приложения

## Часть A. Глоссарий терминов Vibe-Coding

### Основные понятия

| Термин | Определение |
|--------|-------------|
| **Vibe-Coding** | Парадигма программирования, в которой фокус смещён с синтаксиса на семантику и интенцию. Разработчик формулирует *что* нужно сделать, а ИИ генерирует *как* это реализовать. |
| **Coder-LLM** | Большие языковые модели, специализированные для генерации кода: GPT-4, Claude, Code Llama, Gemini и др. |
| **Интенция (Intent)** | Чёткое описание цели, контекста и ограничений задачи. Ключевой элемент Vibe-Coding, определяющий качество генерации. |
| **Семантика** | Смысловое содержание кода в противовес синтаксической форме. В Vibe-Coding семантическая точность важнее синтаксической корректности. |
| **Архитектор интенций** | Новая роль разработчика в парадигме Vibe-Coding: формулировать задачи, управлять контекстом и верифицировать результаты. |

### Психология взаимодействия с ИИ

| Термин | Определение |
|--------|-------------|
| **Метафора стажёра (Intern)** | Способ восприятия LLM: модель обладает энтузиазмом и скоростью, но не имеет контекста вашего проекта, как начинающий разработчик. |
| **State (состояние сессии)** | Динамически развивающийся контекст диалога с ИИ, включающий принятые решения, ограничения и стиль взаимодействия. |
| **Рефрейминг** | Техника повторного упоминания ключевых решений для сохранения и обновления контекста в длинных сессиях. |
| **Контекстное окно** | Ограниченная область памяти LLM (от 4K до 128K+ токенов), в которой модель "держит в уме" информацию для генерации. |
| **Токен** | Минимальная единица текста для LLM. Примерно 4 символа в английском языке и 2-3 символа в русском. |
| **Чёрный ящик** | Характеристика LLM как системы с непрозрачными внутренними механизмами принятия решений. |
| **Когнитивная нагрузка** | Объём рабочей памяти, необходимый для решения задачи. Vibe-Coding перераспределяет нагрузку: разработчик = идея, ИИ = имплементация. |

### Инструменты Vibe-Coding

| Термин | Определение |
|--------|-------------|
| **Cursor** | IDE с глубокой интеграцией ИИ, мультимодальным вводом и автоматическим рефакторингом. Создан для работы в парадигме Vibe-Coding. |
| **Warp** | ИИ-терминал с блочным редактированием команд, автодополнением и сохранением сессий. Инструмент для эффективной работы в командной строке. |
| **Zed** | Минималистичный редактор на Rust с интеграцией ИИ, максимальной скоростью работы и мультиплатформенностью. |

### Prompt Engineering

| Термин | Определение |
|--------|-------------|
| **Prompt Engineering** | Искусство и наука формулирования запросов к LLM для получения точного, релевантного и эффективного кода. |
| **Семантическая грамматика** | Правила передачи смысла задачи вместо синтаксиса языка программирования. Фокус на "что" вместо "как". |
| **RAM vs Swap** | Принцип управления контекстом: ключевые инструкции держать в контексте (RAM), вспомогательные детали — во внешних файлах (Swap). |
| **Чанкинг** | Техника разбиения длинных запросов на логические части для последовательной обработки. |
| **Резюмирование** | Техника сжатия истории диалога до ключевых моментов для экономии контекстного окна. |
| **Позиционное смещение** | Эффекты primacy/recency: LLM уделяет больше внимания началу и концу контекста, меньше — середине. |

### Методологии Vibe-Coding

| Термин | Определение |
|--------|-------------|
| **FRAME** | Модель формулировки интенции: **F**ocus (фокус), **R**eason (причина), **A**ctors (участники), **M**etrics (метрики), **E**xamples (примеры). |
| **Intent-Driven Development** | Подход к разработке, ведомый интенцией (бизнес-ценностью) вместо технических требований. |
| **Декомпозиция** | Процесс разбиения абстрактной идеи на технически реализуемые компоненты с помощью ИИ. |

### Паттерны Vibe-Coding

| Термин | Определение |
|--------|-------------|
| **Context Anchor (Контекстный якорь)** | Паттерн фиксации контекста: семантическая точка отсчёта, сохраняющая значение на протяжении всей сессии. |
| **Scaffolding (Скаффолдинг)** | Паттерн создания структурного каркаса (заглушки, интерфейсы, комментарии) перед детализацией реализации. |
| **Devil's Advocate (Адвокат дьявола)** | Паттерн критической оценки решений через формулирование деструктивных гипотез и поиск слабых мест. |
| **Intent Reset (Сброс интенции)** | Паттерн перезапуска контекста при потере фокуса или накоплении противоречий в сессии. |
| **Tunnel Vision (Туннельное зрение)** | Паттерн намеренного сужения контекста для точечного решения конкретной подзадачи. |

### Качество и безопасность

| Термин | Определение |
|--------|-------------|
| **Vibe-профиль кода** | Набор характеристик, отражающих intent, контекст создания и особенности генерации кода. |
| **Семантическая валидация** | Проверка соответствия сгенерированного кода исходной интенции, а не только синтаксической корректности. |
| **Технический долг** | TODOs, хардкод, временные решения и другие признаки незавершённости кода. |

### Мульти-агентные системы

| Термин | Определение |
|--------|-------------|
| **Dev-агент** | ИИ-роль для генерации кода. Специализируется на реализации функциональности по спецификации. |
| **Test-агент** | ИИ-роль для генерации и выполнения тестов. Фокусируется на edge cases и property-based testing. |
| **Lead-агент** | ИИ-роль для архитектурных решений и code review. Обладает широким кругозором и использует tree-of-thoughts. |
| **Pipeline Pattern** | Паттерн последовательного взаимодействия агентов: Dev → Test → Lead → финальный результат. |
| **Star Pattern** | Паттерн параллельной координации агентов: все работают одновременно, Lead синхронизирует результаты. |

### CI/CD с ИИ

| Термин | Определение |
|--------|-------------|
| **AI Code Analyzer** | ИИ-компонент CI/CD пайплайна для анализа качества, стиля и потенциальных проблем в коде. |
| **Smart Test Generator** | ИИ-компонент для автоматической генерации тестов на основе анализа исходного кода. |
| **Intelligent Security Scanner** | ИИ-компонент для обнаружения уязвимостей с учётом контекста приложения. |

### Продвинутый промптинг

| Термин | Определение |
|--------|-------------|
| **Root Cause Debugger** | Шаблон промпта для глубокой отладки с поиском первопричины вместо симптоматического лечения. |
| **Rage Prompt** | Шаблон для выхода из циклов ошибок, когда стандартные подходы не работают. |
| **Project Memory System** | Система внешней памяти проекта (markdown-файлы) для сохранения контекста между сессиями. |
| **Context Priming** | Техника предварительной установки контекста перед основным запросом. |

---

## Часть B. Чек-листы для практики

### Чек-лист: Формулировка интенции

**Перед запросом к LLM проверьте:**

- [ ] **Язык и среда**: Указан язык программирования и версия
- [ ] **Входы/выходы**: Описаны входные данные и ожидаемый результат
- [ ] **Ограничения**: Указаны библиотеки, стиль кода, архитектурные требования
- [ ] **Контекст**: Объяснено *почему* и *для чего* нужна эта функциональность
- [ ] **FRAME применён**:
  - Focus — что конкретно нужно сделать?
  - Reason — зачем это нужно?
  - Actors — кто будет использовать?
  - Metrics — как измерить успех?
  - Examples — примеры "как есть" и "как должно быть"

---

### Чек-лист: Управление контекстом

**Во время сессии с LLM:**

- [ ] **Контекст проекта**: Указаны технологии, архитектура, стиль кода
- [ ] **Декомпозиция**: Сложная задача разбита на этапы
- [ ] **Примеры кода**: Показан существующий код как образец стиля
- [ ] **Рефрейминг**: Периодически резюмируются принятые решения
- [ ] **Позиционирование**: Ключевые инструкции в начале и конце запроса
- [ ] **Контекстные якоря**: Используются для фиксации важных решений
- [ ] **Шаблоны**: Применяются для автоматизации стиля запросов

---

### Чек-лист: Проверка результатов ИИ

**После получения кода от LLM:**

- [ ] **Соответствие интенции**: Код решает именно ту задачу, которую вы задали
- [ ] **Edge cases**: Обработаны пограничные случаи (null, пустые данные, большие объёмы)
- [ ] **Безопасность**:
  - [ ] Нет SQL-инъекций (используется параметризация)
  - [ ] Нет XSS-уязвимостей (данные экранируются)
  - [ ] Нет Path Traversal (пути валидируются)
  - [ ] Секреты не захардкожены
- [ ] **Обработка ошибок**: Есть try/catch, понятные сообщения об ошибках
- [ ] **Типы данных**: Используются type hints / типизация
- [ ] **Документация**: Есть docstrings / JSDoc для публичных функций
- [ ] **Тесты**: Сгенерированы или написаны unit-тесты
- [ ] **Актуальность**: Код соответствует документации используемых библиотек

---

### Чек-лист: Мульти-агентная разработка

**При использовании нескольких ИИ-агентов:**

- [ ] **Роли определены**: Чётко разделены Dev, Test, Lead
- [ ] **Паттерн выбран**: Pipeline (последовательный) или Star (параллельный)
- [ ] **Контекст синхронизирован**: Все агенты получают единый контекст проекта
- [ ] **Требования к качеству**: Единые стандарты кода и покрытия тестами
- [ ] **Конфликты разрешены**: Механизм решения противоречивых рекомендаций

---

### Чек-лист: CI/CD с ИИ

**При настройке ИИ-интегрированного пайплайна:**

- [ ] **AI Code Analyzer**: Настроен анализ качества кода
- [ ] **Smart Test Generator**: Автоматическая генерация тестов для изменённых файлов
- [ ] **Intelligent Security Scanner**: Сканирование на уязвимости
- [ ] **Автокомментарии**: ИИ оставляет комментарии в PR
- [ ] **Пороги качества**: Определены минимальные требования для мержа
- [ ] **Человеческий review**: Сохранён как обязательный этап

---

## Часть C. Шаблоны промптов

### Шаблон 1: Генерация кода

```markdown
## Контекст
- Язык: [язык и версия]
- Фреймворк: [название]
- Стиль: [PEP 8 / Airbnb / Google]

## Задача
[Описание того, что нужно реализовать]

## Требования
1. [требование 1]
2. [требование 2]
3. [требование 3]

## Входные данные
[Пример входных данных]

## Ожидаемый результат
[Пример выходных данных]

## Ограничения
- [ограничение 1]
- [ограничение 2]
```

---

### Шаблон 2: Рефакторинг кода

```markdown
## Контекст
Вот код, который нужно улучшить:
```[язык]
[существующий код]
```

## Цели рефакторинга
1. [цель 1]
2. [цель 2]
3. [цель 3]

## Ограничения
- Сохранить API/интерфейс
- Не менять внешнее поведение
- [дополнительные ограничения]

## Стиль
- Использовать type hints
- Добавить docstrings
- Следовать [стандарт]
```

---

### Шаблон 3: Отладка (Root Cause Debugger)

```markdown
## Проблема
Код не работает как ожидается.

## Ожидаемое поведение
[что должно происходить]

## Фактическое поведение
[что происходит на самом деле]

## Код
```[язык]
[проблемный код]
```

## Ошибка (если есть)
```
[текст ошибки]
```

## Что уже пробовал
1. [попытка 1]
2. [попытка 2]

## Запрос
Найди **первопричину** проблемы, а не патч. Объясни почему это происходит.
```

---

### Шаблон 4: Архитектурное решение

```markdown
## Задача
[Бизнес-задача, которую нужно решить]

## Контекст
- Существующий стек: [технологии]
- Команда: [размер, опыт]
- Сроки: [дедлайн]
- Бюджет: [ограничения]

## Требования
- Функциональные:
  1. [требование 1]
  2. [требование 2]
- Нефункциональные:
  1. [производительность]
  2. [масштабируемость]
  3. [безопасность]

## Запрос
Предложи архитектуру с обоснованием выбора. Рассмотри альтернативы.
```

---

### Шаблон 5: Генерация тестов

```markdown
## Код для тестирования
```[язык]
[код функции/класса]
```

## Требования к тестам
- Фреймворк: [pytest / jest / mocha]
- Покрытие: [процент]
- Обязательные кейсы:
  1. Успешный сценарий
  2. Edge cases (пустые данные, null, границы)
  3. Ошибочные сценарии
  4. [специфические кейсы]

## Стиль
- Используй параметризацию
- Добавь описательные названия тестов
- Применяй паттерн AAA (Arrange-Act-Assert)
```

---

## Часть D. Ресурсы для дальнейшего изучения

### Инструменты

| Инструмент | Описание | Ссылка |
|------------|----------|--------|
| Cursor | AI-first IDE | cursor.sh |
| Warp | AI-терминал | warp.dev |
| Zed | Быстрый редактор с ИИ | zed.dev |
| Claude | Модель Anthropic | claude.ai |
| ChatGPT | Модель OpenAI | chat.openai.com |
| GitHub Copilot | ИИ-ассистент для IDE | github.com/features/copilot |

### Фреймворки для мульти-агентных систем

| Фреймворк | Описание |
|-----------|----------|
| LangChain | Оркестрация LLM и агентов |
| LangGraph | Графы агентов с состоянием |
| CrewAI | Командная работа ИИ-агентов |
| AutoGen | Мульти-агентные разговоры |

### Рекомендуемые практики

1. **Начните с простого**: Используйте один LLM для простых задач, прежде чем переходить к мульти-агентным системам
2. **Итеративный подход**: Не ожидайте идеального кода с первого раза — уточняйте и дорабатывайте
3. **Сохраняйте контекст**: Используйте project-memory файлы для сохранения решений между сессиями
4. **Проверяйте всегда**: Code Review человеком остаётся обязательным
5. **Учитесь на ошибках**: Анализируйте, когда ИИ ошибается, чтобы улучшить промпты

---

*Конец Приложений*
