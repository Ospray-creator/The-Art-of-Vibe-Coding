# Глава 4. Алфавит Vibe-Coding (Prompt Engineering)

## 4.1. Язык: Грамматика смысла против синтаксиса языка программирования

### Введение раздела

В предыдущих главах мы рассмотрели философские и методологические основы Vibe-Coding — новой парадигмы программирования, где взаимодействие с Coder-LLM строится не на формальной точности синтаксиса, а на передаче семантического намерения. Мы обсудили концепцию *vibe* как ключевого элемента коммуникации, а также базовые принципы формирования запросов (*промптов*), которые позволяют ИИ не просто выполнять команды, но понимать контекст задачи на глубоком уровне.

Однако переход от традиционного программирования к Vibe-Coding требует не только новой техники, но и нового взгляда на сам язык — не как на набор жестких правил, а как на инструмент передачи смысла. В этом разделе мы деконструируем привычное понимание языка программирования и исследуем, как в Vibe-Coding грамматика трансформируется из синтаксической в семантическую.

Цель раздела — научить вас мыслить не в терминах компилятора (который требует точных инструкций), а в терминах интенции (которую способен интерпретировать ИИ). Мы разберем, как традиционные языки программирования ограничивают выразительность, почему семантический подход эффективнее в контексте Coder-LLM, и как строить запросы так, чтобы ИИ не просто выполнял код, но *понимал* его назначение.

К концу этого раздела вы сможете:
- Различать синтаксическую и семантическую грамматику;
- Формулировать запросы с акцентом на намерение, а не на формальные правила;
- Избегать распространенных ошибок при переходе от традиционного программирования к Vibe-Coding;
- Применять практические техники для улучшения взаимодействия с Coder-LLM.

---

## **Основная теория: Грамматика смысла против синтаксиса**

### **1. Язык программирования как формальная система**

Традиционные языки программирования (Python, Java, C++) — это формальные системы, построенные на строгих синтаксических правилах. Их грамматика описывается контекстно-свободными грамматиками (например, в форме Бэкуса-Наура), где каждое выражение должно соответствовать заранее определенной структуре.

**Пример формального синтаксиса (Python):**
```python
if x > 0:
    print("Positive")
else:
    print("Non-positive")
```
Здесь каждое слово (`if`, `else`, `:`, отступы) имеет строгое значение, а любое отклонение ведет к синтаксической ошибке.

**Особенности синтаксической грамматики:**
- **Жесткость**. Компилятор требует точного соответствия правилам. Ошибка в одном символе делает код неработоспособным.
- **Однозначность**. Каждая конструкция имеет единственное толкование (в теории).
- **Ограниченная выразительность**. Семантика задачи часто теряется за синтаксическими деталями.

В этом подходе программист выступает в роли "переводчика": он должен трансформировать свою мысль в жесткий синтаксис, понятный машине. Однако человеческое мышление нелинейно и контекстно-зависимо — мы формулируем идеи в терминах целей, а не инструкций.

---

### **2. Семантическая грамматика: Язык как средство передачи намерения**

Vibe-Coding переворачивает эту модель с ног на голову. Вместо того чтобы подстраивать свою мысль под синтаксис языка, разработчик формулирует запрос в терминах *намерения*, а Coder-LLM интерпретирует его и генерирует корректный код.

**Ключевые отличия семантической грамматики:**
| **Аспект**               | **Синтаксическая грамматика**               | **Семантическая грамматика**                |
|--------------------------|--------------------------------------------|--------------------------------------------|
| **Цель**                 | Точное выполнение инструкций               | Передача смысла задачи                     |
| **Гибкость**             | Низкая (ошибки критичны)                  | Высокая (ИИ адаптируется к формулировкам)  |
| **Роль разработчика**    | Переводчик мыслей в код                   | Архитектор намерений                       |
| **Язык запросов**        | Формальный синтаксис (Python, Java)       | Естественный язык + технические термины    |
| **Обработка ошибок**     | Компилятор отвергает некорректный код      | ИИ уточняет неясные моменты                |

**Пример семантического запроса:**
Вместо написания кода вручную:
```python
# Традиционный подход
def filter_even_numbers(numbers):
    return [x for x in numbers if x % 2 == 0]
```
В Vibe-Coding разработчик формулирует запрос так:
> *"Напиши функцию на Python, которая принимает список чисел и возвращает только четные. Используй list comprehension для эффективности. Если входные данные некорректны (например, содержат строки), возвращай пустой список."*

Coder-LLM генерирует:
```python
def filter_even_numbers(numbers):
    try:
        return [x for x in numbers if isinstance(x, int) and x % 2 == 0]
    except TypeError:
        return []
```
**Почему это работает?**
- ИИ понимает *намерение* (фильтрация четных чисел), а не просто синтаксис.
- Запрос содержит *контекст* (обработка ошибок, требование к типу данных).
- Нет жесткой привязки к конкретной реализации (можно было бы использовать и цикл `for`).

---

### **3. Исторический контекст: Почему семантика важнее синтаксиса?**

Эволюция языков программирования всегда шла в сторону повышения уровня абстракции:
1. **Машинный код** → жесткие инструкции для процессора.
2. **Ассемблер** → мнемоники вместо бинарных команд.
3. **Высокоуровневые языки (C, Java)** → абстракции (функции, классы).
4. **Декларативные языки (SQL, Prolog)** → описание *что*, а не *как*.
5. **Vibe-Coding** → описание *почему* и *зачем*.

Каждый шаг уменьшал синтаксическую нагрузку на разработчика, позволяя сосредоточиться на семантике задачи. Coder-LLM доводит этот тренд до логического завершения: теперь можно передавать не только *что* нужно сделать, но и *какой эффект* ожидается от кода.

---

### **4. Метафоры для понимания семантической грамматики**

#### **Метафора 1: Рецепт vs. Конечный результат**
- **Синтаксическая грамматика** — это как следование рецепту пошагово: "Возьмите 200 г муки, добавьте 1 яйцо, перемешайте". Ошибка в одном шаге испортит блюдо.
- **Семантическая грамматика** — это как сказать повару: "Я хочу шоколадный торт с орехами". Шеф сам решит, какие ингредиенты и шаги нужны.

#### **Метафора 2: Чертеж vs. Техническое задание**
- **Синтаксис** — это чертеж моста, где каждый болт и сварной шов указан явно.
- **Семантика** — это техническое задание: "Построй мост через реку длиной 500 м, выдерживающий нагрузку 1000 тонн". Инженер сам выберет материалы и конструкцию.

---

### **5. Почему семантическая грамматика эффективнее?**

1. **Снижение когнитивной нагрузки**
   Разработчику не нужно помнить все синтаксические нюансы (например, как работает `reduce` в Python vs. JavaScript). Достаточно описать задачу, а ИИ подберет подходящий инструмент.

2. **Адаптивность к контексту**
   В традиционном программировании код завязан на конкретную среду (например, версия Python). В Vibe-Coding можно добавить контекст:
   > *"Напиши функцию для Python 3.10 с использованием match-case для обработки разных типов данных."*

3. **Обработка неопределенности**
   В реальных задачах часто есть неясности (например, как обрабатывать null). Вместо долгого дебаггинга можно поручить это ИИ:
   > *"Если входные данные None, возвращай пустой список. В остальных случаях фильтруй четные числа."*

4. **Экономия времени**
   Исследования показывают, что до 30% времени разработчика уходит на поиск синтаксических ошибок и документации. Vibe-Coding минимизирует эту проблему.

---

## **Практические примеры: От синтаксиса к семантике**

### **Пример 1: Фильтрация данных (сравнение подходов)**

**Традиционный подход (синтаксис):**
```python
# Разработчик пишет вручную
def filter_adults(people):
    return [p for p in people if p['age'] >= 18]
```
Проблемы:
- Нужно помнить синтаксис list comprehension.
- Нет обработки ошибок (например, если `age` — строка).

**Vibe-Coding подход (семантика):**
Запрос:
> *"Напиши функцию на Python, которая принимает список словарей с ключами 'name' и 'age'. Функция должна возвращать только словари, где возраст больше или равен 18. Если возраст не число или отсутствует, игнорируй такой элемент. Используй функциональный стиль с filter и lambda."*

Результат от Coder-LLM:
```python
def filter_adults(people):
    return list(
        filter(
            lambda p: isinstance(p.get('age'), int) and p['age'] >= 18,
            people
        )
    )
```

**Сравнительная таблица:**
| **Критерий**            | **Традиционный подход**               | **Vibe-Coding**                          |
|-------------------------|---------------------------------------|------------------------------------------|
| **Время написания**     | 2-5 минут                             | 30 секунд (формулировка запроса)         |
| **Обработка ошибок**    | Нет                                   | Автоматическая                           |
| **Гибкость**            | Низкая (только один способ решения)   | Высокая (ИИ предлагает варианты)         |
| **Читаемость**          | Хорошая                               | Отличная (с комментариями от ИИ)         |

---

### **Пример 2: Обработка файлов**

**Традиционный подход:**
```python
# Чтение и парсинг CSV-файла
import csv

with open('data.csv', 'r') as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(row)
```
Проблемы:
- Нужно помнить синтаксис `csv.DictReader`.
- Нет обработки ошибок (файл не найден, некорректный формат).

**Vibe-Coding подход:**
Запрос:
> *"Напиши скрипт на Python, который читает CSV-файл 'data.csv' и выводит каждую строку как словарь. Если файл не существует, выведи сообщение об ошибке. Если в строке не хватает колонок, пропусти ее. Используй pandas для удобства."*

Результат от Coder-LLM:
```python
import pandas as pd

try:
    df = pd.read_csv('data.csv')
    for _, row in df.iterrows():
        print(row.to_dict())
except FileNotFoundError:
    print("Ошибка: Файл data.csv не найден.")
except pd.errors.ParserError:
    print("Ошибка: Некорректный формат CSV.")
```

**Ключевые отличия:**
- ИИ выбрал библиотеку `pandas` вместо `csv`, так как она более удобна.
- Добавлена обработка исключений.
- Код более лаконичный и надежный.

---

### **Пример 3: Генерация отчетов**

**Традиционный подход:**
```python
# Формирование HTML-отчета
html = "<html><body><h1>Отчет</h1><ul>"
for item in data:
    html += f"<li>{item['name']}: {item['value']}</li>"
html += "</ul></body></html>"
```
Проблемы:
- Уязвимость к XSS (если `name` или `value` содержат HTML-теги).
- Нет форматирования чисел/дат.

**Vibe-Coding подход:**
Запрос:
> *"Сгенерируй HTML-отчет на основе списка словарей data. Каждый элемент должен содержать имя и значение. Значения должны быть отформатированы как числа с двумя десятичными знаками. Защити от XSS-атак. Используй Jinja2 для шаблонов."*

Результат от Coder-LLM:
```python
from jinja2 import Environment, escape

env = Environment(autoescape=True)
template = env.from_string("""
<html>
<body>
<h1>Отчет</h1>
<ul>
{% for item in data %}
    <li>{{ item.name | e }}: {{ "%.2f"|format(item.value) }}</li>
{% endfor %}
</ul>
</body>
</html>
""")

html_report = template.render(data=data)
```

**Преимущества:**
- Автоматическое экранирование (`| e`) для защиты от XSS.
- Форматирование чисел через фильтры Jinja2.
- Более читаемый и поддерживаемый код.

---

### **Пример 4: API-запросы**

**Традиционный подход:**
```python
# Запрос к API с retry-логикой
import requests
import time

max_retries = 3
for attempt in range(max_retries):
    try:
        response = requests.get('https://api.example.com/data')
        response.raise_for_status()
        data = response.json()
        break
    except requests.exceptions.RequestException as e:
        if attempt == max_retries - 1:
            raise
        time.sleep(2 ** attempt)
```
Проблемы:
- Нужно помнить про экспоненциальный backoff.
- Нет обработки специфичных статусов (например, 429 Too Many Requests).

**Vibe-Coding подход:**
Запрос:
> *"Напиши функцию на Python, которая делает GET-запрос к API и возвращает JSON-ответ. Реализуй retry-логику с экспоненциальным ожиданием (максимум 3 попытки). Если API возвращает 429, жди указанное в заголовке Retry-After время. Используй библиотеку requests и не забывай про тайм-ауты."*

Результат от Coder-LLM:
```python
import requests
import time

def fetch_api_data(url, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 429:
                retry_after = int(response.headers.get('Retry-After', 2 ** attempt))
                time.sleep(retry_after)
                continue
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise
            time.sleep(2 ** attempt)
    raise Exception("Не удалось получить данные после нескольких попыток")
```

**Улучшения:**
- Обработка `429 Too Many Requests`.
- Тайм-аут для запроса.
- Более четкая логика retry.

---

### **Пример 5: Асинхронное программирование**

**Традиционный подход:**
```python
# Асинхронный парсинг нескольких URL
import asyncio
import aiohttp

async def fetch_url(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    urls = ['https://example.com', 'https://example.org']
    tasks = [fetch_url(url) for url in urls]
    results = await asyncio.gather(*tasks)
    print(results)

asyncio.run(main())
```
Проблемы:
- Нужно помнить про `async`/`await`.
- Нет обработки ошибок для отдельных запросов.

**Vibe-Coding подход:**
Запрос:
> *"Напиши асинхронную функцию на Python, которая параллельно загружает содержимое нескольких URL и возвращает список результатов. Если какой-то запрос завершился с ошибкой, возвращай None для этого URL. Используй aiohttp и asyncio. Ограничь количество одновременных запросов до 5."*

Результат от Coder-LLM:
```python
import asyncio
import aiohttp
from typing import List, Optional

async def fetch_url(session: aiohttp.ClientSession, url: str) -> Optional[str]:
    try:
        async with session.get(url, timeout=10) as response:
            response.raise_for_status()
            return await response.text()
    except (aiohttp.ClientError, asyncio.TimeoutError):
        return None

async def fetch_all_urls(urls: List[str], max_concurrent: int = 5) -> List[Optional[str]]:
    connector = aiohttp.TCPConnector(limit=max_concurrent)
    async with aiohttp.ClientSession(connector=connector) as session:
        tasks = [fetch_url(session, url) for url in urls]
        return await asyncio.gather(*tasks)

# Пример использования
results = asyncio.run(fetch_all_urls(['https://example.com', 'https://example.org']))
print(results)
```

**Улучшения:**
- Ограничение одновременных запросов (`limit=5`).
- Обработка ошибок для каждого запроса.
- Более читаемый код с аннотациями типов.

---

### **Пример 6: Работа с базами данных**

**Традиционный подход:**
```python
# SQL-запрос с параметризацией
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()
cursor.execute("SELECT * FROM users WHERE age > ?", (18,))
results = cursor.fetchall()
conn.close()
```
Проблемы:
- Нужно помнить про параметризацию для защиты от SQL-инъекций.
- Нет контекстного менеджера (можно забыть закрыть соединение).

**Vibe-Coding подход:**
Запрос:
> *"Напиши функцию на Python, которая подключается к SQLite базе данных и возвращает всех пользователей старше заданного возраста. Используй контекстный менеджер для автоматического закрытия соединения. Защити от SQL-инъекций с помощью параметризации. Верни результаты в виде списка словарей."*

Результат от Coder-LLM:
```python
import sqlite3
from typing import List, Dict

def get_users_older_than(age: int, db_path: str = 'example.db') -> List[Dict]:
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row  # Возвращаем словари
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE age > ?", (age,))
        return [dict(row) for row in cursor.fetchall()]
```

**Улучшения:**
- Автоматическое закрытие соединения через `with`.
- Результаты в виде словарей (удобнее для работы).
- Аннотации типов для ясности.

---

### **Пример 7: Тестирование**

**Традиционный подход:**
```python
# Юнит-тест для функции
import unittest

class TestMathFunctions(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
    def test_add_errors(self):
        with self.assertRaises(TypeError):
            add("2", 3)
```
Проблемы:
- Нужно помнить синтаксис `unittest`.
- Нет тестов на граничные случаи (например, большие числа).

**Vibe-Coding подход:**
Запрос:
> *"Напиши юнит-тесты для функции add(a, b), которая складывает два числа. Покрой следующие случаи:
> - Положительные числа
> - Отрицательные числа
> - Нули
> - Большие числа (1e6)
> - Ошибки при передаче строк вместо чисел
> Используй pytest и напиши параметризованные тесты."*

Результат от Coder-LLM:
```python
import pytest
from typing import Union

def add(a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Аргументы должны быть числами")
    return a + b

@pytest.mark.parametrize("a, b, expected", [
    (2, 3, 5),
    (-1, 1, 0),
    (0, 0, 0),
    (1e6, 1e6, 2e6),
    (2.5, 3.5, 6.0)
])
def test_add(a, b, expected):
    assert add(a, b) == expected

def test_add_type_error():
    with pytest.raises(TypeError):
        add("2", 3)
```

**Улучшения:**
- Параметризованные тесты (меньше дублирования кода).
- Проверка типов в самой функции.
- Более широкое покрытие случаев.

---

## **Распространенные ошибки при переходе к семантической грамматике**

Переход от синтаксиса к семантике — это не просто смена инструмента, а изменение мышления. Вот типичные ошибки, с которыми сталкиваются разработчики:

### **1. Избыточная детализация (Overprompting)**
**Ошибка:**
Формулировка запроса с излишними деталями, как будто адресована новичку:
> *"Напиши функцию на Python, которая принимает два аргумента, оба должны быть числами, и возвращает их сумму. Используй оператор +. Если аргументы не числа, вызывай исключение TypeError с сообщением 'Аргументы должны быть числами'."*

**Проблема:**
- Coder-LLM и так понимает базовые концепции.
- Избыточные инструкции усложняют запрос и могут запутать ИИ.

**Как исправить:**
Формулируйте запрос компактно, акцентируя внимание на нетривиальных моментах:
> *"Напиши функцию add(a, b), которая возвращает сумму чисел. Проверяй типы аргументов и выбрасывай TypeError при ошибке."*

---

### **2. Недостаточная контекстуализация (Underprompting)**
**Ошибка:**
Запрос без контекста или ограничений:
> *"Напиши функцию для сортировки списка."*

**Проблема:**
- ИИ может выбрать неэффективный алгоритм (например, bubble sort).
- Нет указаний на обработку дубликатов или нестандартных типов данных.

**Как исправить:**
Добавляйте контекст:
> *"Напиши функцию на Python для сортировки списка объектов по возрастанию значения поля 'price'. Используй встроенную сортировку с ключом. Если объекты не содержат поле 'price', игнорируй их."*

---

### **3. Игнорирование обработки ошибок**
**Ошибка:**
Предполагать, что ИИ автоматически добавит обработку ошибок:
> *"Напиши функцию, которая читает файл и возвращает его содержимое."*

**Проблема:**
ИИ может сгенерировать код без проверки существования файла или прав доступа.

**Как исправить:**
Явно указывайте требования к обработке ошибок:
> *"Напиши функцию, которая читает файл и возвращает его содержимое. Если файл не найден или недоступен для чтения, возвращай пустую строку."*

---

### **4. Привязка к конкретной реализации**
**Ошибка:**
Требовать от ИИ использовать определенный алгоритм или библиотеку без обоснования:
> *"Реализуй сортировку пузырьком для списка чисел."*

**Проблема:**
- ИИ знает более эффективные алгоритмы (например, Timsort в Python).
- Запрос ограничивает гибкость решения.

**Как исправить:**
Фокусируйтесь на результате, а не на методе:
> *"Реализуй функцию сортировки списка чисел по возрастанию. Оптимизируй ее для больших объемов данных."*

---

### **5. Неиспользование контекста**

---

## 4.2. Точность: Как формулировать намеки, не ограничивая креативность, но сохраняя курс

### Введение раздела

В предыдущем разделе мы рассмотрели базовые принципы *prompt engineering* в парадигме *Vibe-Coding*, где ключевую роль играет не столько синтаксическая точность, сколько передача намерения (*intent*). Однако между свободой творчества и направленным результатом существует тонкая грань: слишком расплывчатые инструкции ведут к нерелевантным ответам, а излишняя детализация подавляет креативность модели. В этом разделе мы исследуем концепцию **точности в Vibe-Coding** — искусство формулировать запросы так, чтобы они оставались открытыми для интерпретации, но при этом сохраняли целевую направленность.

Цели раздела:
1. Разобрать понятие **семантической точности** в контексте работы с Coder-LLM.
2. Сравнить традиционные подходы к спецификации требований с гибкими техниками *Vibe-Coding*.
3. Выработать методику балансировки между свободой и контролем через практические примеры.
4. Проанализировать распространенные ошибки и стратегии их предотвращения.

Понимание точности в *Vibe-Coding* критически важно, поскольку оно напрямую влияет на качество выходного кода, скорость итераций и даже на долгосрочную адаптивность решений. В отличие от классического программирования, где точность достигается через строгие формальные спецификации, здесь она рождается из **продуманной недоговоренности** — умения оставлять пространство для творчества модели, не теряя контроль над результатом.

---

## **Основная теория**

### **1. Точность в традиционном программировании vs. Vibe-Coding**

В классической разработке точность реализуется через:
- **Формальные спецификации** (например, UML-диаграммы, Swagger-документы).
- **Жесткие сигнатуры функций** (типы данных, контракты).
- **Тесты с фиксированными ожиданиями** (unit/integration tests).

Эти инструменты обеспечивают детерминированность, но ограничивают гибкость. В *Vibe-Coding* точность смещается в плоскость **семантической валидности** — когда код:
- Решает задачу по назначению, а не по букве спецификации.
- Адаптируется к контексту, а не следует жесткому алгоритму.
- Сохраняет читаемость и поддерживаемость, даже если реализация неочевидна.

**Пример сравнения:**
| Подход               | Традиционное программирование                          | Vibe-Coding                                      |
|----------------------|-------------------------------------------------------|-------------------------------------------------|
| **Способ задания**   | "Функция должна принимать два целых числа и возвращать их сумму" | "Реализуй функцию для сложения, которая будет интуитивно понятна в контексте финансовых расчетов" |
| **Гибкость**         | Низкая (требует рефакторинга при изменении требований) | Высокая (модель может предложить разные варианты) |
| **Креативность**     | Ограничена рамками спецификации                       | Поощряется (например, предложение оптимизаций)  |

### **2. Исторический контекст: от точных инструкций к намерениям**

Эволюция подходов к точности в разработке:
1. **Эра перфокарт (1950-1960)**:
   - Точность = буквальное соответствие машинным инструкциям.
   - Ошибка в одном символе приводила к сбою.
2. **Структурное программирование (1970-1980)**:
   - Введение модульности и абстракций (функции, процедуры).
   - Точность = соблюдение сигнатур и контрактов.
3. **Agile и гибкие методологии (2000-е)**:
   - Акцент на пользовательских историях (*user stories*) вместо жестких требований.
   - Точность = соответствие бизнес-целям, а не формальным критериям.
4. **Vibe-Coding (2020-е)**:
   - Точность = передача **интенции** и контекста, а не деталей реализации.
   - Модель выступает как соавтор, а не исполнитель.

**Ключевая идея:**
> В *Vibe-Coding* точность — это не про отсутствие неоднозначности, а про ее **управляемое использование**.

### **3. Метафоры для понимания точности**

#### **Метафора 1: Рецепт vs. Вдохновение**
- **Традиционное программирование** = рецепт с точными ингредиентами и шагами.
  *"Смешай 200 г муки, 100 г сахара, добавь 2 яйца, выпекай при 180°C 20 минут."*
- **Vibe-Coding** = просьба "испечь что-то сладкое и воздушное, чтобы порадовать гостей".
  - Модель сама предложит варианты (кекс, пирог, маффины) и уточнит детали (диетические предпочтения гостей).

#### **Метафора 2: Навигация по карте vs. Путешествие с компасом**
- **Традиционный подход** = следовать GPS-навигации пошагово.
- **Vibe-Coding** = задать конечную точку и общее направление ("двигайся на север, избегая болот"), оставив выбор пути на усмотрение модели.

### **4. Теоретическая модель точности в Vibe-Coding**

Точность в *Vibe-Coding* можно представить как **спектр**:
```
Низкая точность (расплывчатость) ----------------- Высокая точность (ограниченность)
|_________________________________________________________|
   Креативность ↑                              Детерминизм ↑
```

**Оптимальная зона** — это **баланс между**:
- **Контекстом**: Достаточно информации для понимания задачи.
- **Свободой**: Возможность предложить альтернативные решения.
- **Ограничениями**: Явные запреты или требования (например, "без использования библиотек").

**Пример спектра:**
| Уровень точности          | Пример prompt                                      | Риски и преимущества                          |
|---------------------------|----------------------------------------------------|-----------------------------------------------|
| **Низкий**                | "Напиши код для обработки данных"                 | + Креативные решения<br>- Нерелевантный код |
| **Оптимальный**           | "Реализуй парсинг CSV-файлов с валидацией данных. Используй Python, но избегай pandas, если есть более элегантное решение" | + Сбалансированный результат                 |
| **Высокий**               | "Напиши функцию на Python, которая принимает строку в формате 'имя,возраст', разделяет по запятой, и возвращает словарь {'name': значение, 'age': значение}" | + Точный результат<br>- Нет места для оптимизаций |

---

## **Практические примеры**

### **Пример 1: Генерация API-эндпоинта**

**Задача:** Создать эндпоинт для получения пользователя по ID.

#### **Подход с низкой точностью (проблемный)**
```plaintext
Напиши API для получения пользователя.
```
**Проблемы:**
- Не указан язык/фреймворк.
- Нет контекста о структуре данных.
- Модель может предложить неэффективное решение (например, без кэширования).

#### **Подход с высокой точностью (ограничивающий)**
```plaintext
Напиши FastAPI эндпоинт на Python:
@app.get("/users/{user_id}")
async def get_user(user_id: int) -> dict:
    return {"id": user_id, "name": "John Doe", "email": "john@example.com"}
```
**Проблемы:**
- Жестко задано возвращаемое значение (негибко).
- Нет обработки ошибок.
- Модель лишена творчества.

#### **Оптимальный подход (Vibe-Coding)**
```plaintext
Реализуй FastAPI эндпоинт для получения пользователя по ID.
Требования:
1. Используй асинхронный подход.
2. Обработай случаи, когда пользователь не найден (возвращай 404).
3. Данные хранятся в базе, но для примера можешь использовать mock-объект.
4. Структура ответа: id, имя, email, дата регистрации.
5. Добавь примеры запроса/ответа в документации.
```
**Почему это работает:**
- Задан **контекст** (FastAPI, асинхронность, база данных).
- Оставлена **свобода** в реализации (mock или реальная БД).
- Указаны **ограничения** (структура ответа, обработка ошибок).

**Результат (пример от модели):**
```python
from fastapi import FastAPI, HTTPException
from datetime import datetime
from typing import Dict, Optional

app = FastAPI()

# Mock database
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com", "registered_at": "2023-01-15"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com", "registered_at": "2023-02-20"}
}

@app.get("/users/{user_id}", response_model=Dict[str, Optional[str | int | datetime]]])
async def get_user(user_id: int):
    user = users_db.get(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

"""
Примеры:
Запрос: GET /users/1
Ответ: {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "registered_at": "2023-01-15"
}
"""
```

---

### **Пример 2: Рефакторинг legacy-кода**

**Задача:** Улучшить читаемость и производительность функции.

#### **Исходный код (проблемный)**
```python
def process_data(data):
    res = []
    for i in range(len(data)):
        if data[i] % 2 == 0:
            res.append(data[i] * 2)
        else:
            res.append(data[i] / 2)
    return res
```

#### **Подход с низкой точностью**
```plaintext
Улучши этот код.
```
**Проблемы:**
- Модель может предложить поверхностные изменения (переименование переменных).
- Нет контекста о цели рефакторинга.

#### **Подход с высокой точностью**
```plaintext
Замени цикл на list comprehension и добавь аннотации типов.
```
**Проблемы:**
- Игнорирует потенциальные оптимизации (например, использование `map`).
- Ограничивает креативность модели.

#### **Оптимальный подход**
```plaintext
Проведи рефакторинг этой функции для улучшения:
1. Читаемости (используй Python-стиль и понятные имена).
2. Производительности (избегай лишних итераций).
3. Безопасности (обработай возможные ошибки, например, деление на 0).
4. Гибкости (сделай функцию пригодной для разных типов данных, если это имеет смысл).

Сохрани исходную логику (четные числа умножать на 2, нечетные делить на 2).
```
**Результат:**
```python
from typing import List, Union

def process_data(data: List[Union[int, float]]) -> List[float]:
    """
    Обрабатывает список чисел: четные умножает на 2, нечетные делит на 2.

    Args:
        data: Список чисел (int или float).

    Returns:
        Список обработанных чисел.

    Raises:
        ValueError: Если в списке нечисловые значения или деление на 0.
    """
    if not all(isinstance(x, (int, float)) for x in data):
        raise ValueError("All elements must be numbers")

    return [
        x * 2 if x % 2 == 0 else x / 2
        for x in data
    ]
```

**Ключевые улучшения:**
1. Добавлены аннотации типов и docstring.
2. Использован list comprehension вместо цикла.
3. Добавлена обработка ошибок.
4. Сохранена исходная логика, но код стал безопаснее и читаемее.

---

### **Пример 3: Генерация тестов**

**Задача:** Написать unit-тесты для функции `process_data` из примера 2.

#### **Подход с низкой точностью**
```plaintext
Напиши тесты для этой функции.
```
**Проблемы:**
- Модель может ограничиться тривиальными тестами.
- Нет контекста о важных edge cases.

#### **Подход с высокой точностью**
```plaintext
Напиши pytest-тесты с проверкой:
- Четных чисел
- Нечетных чисел
- Пустого списка
- Отрицательных чисел
```
**Проблемы:**
- Не учитывает потенциальные ошибки (например, строки в списке).
- Нет гибкости в выборе фреймворка тестирования.

#### **Оптимальный подход**
```plaintext
Напиши исчерпывающие тесты для функции `process_data`.
Покрой:
1. Основные сценарии (четные/нечетные числа).
2. Edge cases (пустой список, отрицательные числа, нули).
3. Обработку ошибок (нечисловые значения, деление на 0).
4. Производительность (если функция будет использоваться на больших данных).

Используй pytest, но если есть более подходящий инструмент для Python (например, unittest), можешь предложить его.
```
**Результат:**
```python
import pytest
from process_data import process_data

def test_process_even_numbers():
    assert process_data([2, 4, 6]) == [4, 8, 12]

def test_process_odd_numbers():
    assert process_data([1, 3, 5]) == [0.5, 1.5, 2.5]

def test_process_mixed_numbers():
    assert process_data([1, 2, 3, 4]) == [0.5, 4, 1.5, 8]

def test_empty_list():
    assert process_data([]) == []

def test_negative_numbers():
    assert process_data([-2, -1]) == [-4, -0.5]

def test_zero():
    assert process_data([0]) == [0]  # 0 считается четным

def test_non_numeric_values():
    with pytest.raises(ValueError):
        process_data([1, "two", 3])

def test_division_by_zero():
    with pytest.raises(ZeroDivisionError):
        process_data([1, 0])  # Хотя 0 четное, деление не происходит
```

---

### **Пример 4: Проектирование архитектуры**

**Задача:** Разработать архитектуру микросервиса для обработки заказов.

#### **Подход с низкой точностью**
```plaintext
Спроектируй микросервис для заказов.
```
**Проблемы:**
- Модель может предложить слишком общий или нерелевантный дизайн.

#### **Подход с высокой точностью**
```plaintext
Реализуй микросервис на Node.js с:
- REST API
- MongoDB для хранения заказов
- JWT-аутентификацией
- Docker-контейнеризацией
```
**Проблемы:**
- Ограничивает выбор технологий (например, PostgreSQL может быть лучше для транзакций).
- Не учитывает бизнес-требования (например, масштабируемость).

#### **Оптимальный подход**
```plaintext
Спроектируй архитектуру микросервиса для обработки заказов в онлайн-магазине.
Требования:
1. Обеспечь высокую доступность (uptime 99.9%).
2. Данные должны быть согласованными (заказы нельзя терять).
3. Поддерживай горизонтальное масштабирование.
4. Учти интеграцию с платежными системами и складом.
5. Выбери технологии, которые лучше всего подходят для этих задач (язык, БД, брокер сообщений и т.д.).

Опиши:
- Основные компоненты и их взаимодействие.
- Диаграмму архитектуры (можешь описать ее текстово).
- Потенциальные риски и их смягчение.
```
**Результат (фрагмент):**
```plaintext
Архитектура микросервиса заказов:

1. Компоненты:
   - API Gateway (Kong/NGINX): маршрутизация запросов, аутентификация, rate limiting.
   - Order Service (Go): основная логика обработки заказов (создание, обновление статуса).
   - Payment Service (Node.js): интеграция с платежными шлюзами (Stripe, PayPal).
   - Inventory Service (Python): проверка остатков на складе.
   - Notification Service (Python): отправка email/SMS уведомлений.
   - Database: PostgreSQL (для транзакционной целостности) + Redis (для кэширования часто запрашиваемых данных).
   - Message Broker: RabbitMQ для асинхронного взаимодействия между сервисами.

2. Взаимодействие:
   - Клиент → API Gateway → Order Service → Payment Service/Inventory Service.
   - При успешной оплате Order Service публикует событие "OrderConfirmed" в RabbitMQ.
   - Notification Service и Inventory Service подписаны на это событие.

3. Диаграмма (текстовое описание):
   [API Gateway] → [Order Service]
                   ↓
   [Payment Service] ←→ [Inventory Service]
                   ↓
   [RabbitMQ] → [Notification Service]

4. Риски и смягчение:
   - Риск: Потеря заказов при сбое Payment Service.
     Решение: Использовать Saga Pattern для распределенных транзакций.
   - Риск: Перегрузка базы данных при пиковых нагрузках.
     Решение: Кэширование частых запросов (Redis), шардирование БД.
```

---

### **Пример 5: Оптимизация SQL-запросов**

**Задача:** Улучшить производительность медленного SQL-запроса.

#### **Исходный запрос**
```sql
SELECT u.*, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active'
ORDER BY o.created_at DESC;
```

#### **Подход с низкой точностью**
```plaintext
Оптимизируй этот SQL-запрос.
```
**Проблемы:**
- Модель может предложить тривиальные улучшения (добавление индексов).
- Нет контекста о объеме данных и структуре таблиц.

#### **Подход с высокой точностью**
```plaintext
Добавь индекс на колонку `status` и измени `JOIN` на `LEFT JOIN`.
```
**Проблемы:**
- `LEFT JOIN` может ухудшить производительность, если нужны только активные пользователи.
- Не учитывает, что индекс уже может существовать.

#### **Оптимальный подход**
```plaintext
Этот запрос работает медленно на базе с 10 млн пользователей и 50 млн заказов.
Цели оптимизации:
1. Сократить время выполнения до <100 мс.
2. Уменьшить нагрузку на базу (сейчас запрос сканирует всю таблицу `orders`).
3. Сохранить текущую логику (фильтрация активных пользователей и сортировка заказов).

Требования:
- Используй PostgreSQL 15.
- Доступны любые индексы, но избегай избыточных (они замедляют запись).
- Если оптимизация требует изменения структуры данных, предложи варианты.

Проанализируй текущий запрос и предложи улучшения.
```
**Результат:**
```sql
-- 1. Анализ проблем:
-- - Нет индекса на `status` (сканирование всей таблицы users).
-- - Нет индекса на `user_id` в таблице orders (дорогой JOIN).
-- - Сортировка по `created_at` без индекса (дорогая операция).

-- 2. Предлагаемые индексы:
CREATE INDEX idx_users_status ON users(status) WHERE status = 'active';
CREATE INDEX idx_orders_user_id_created_at ON orders(user_id, created_at DESC);

-- 3. Оптимизированный запрос:
SELECT u.*, o.total_amount
FROM users u
JOIN (
    SELECT user_id, total_amount, created_at
    FROM orders
    ORDER BY created_at DESC
) o ON u.id = o.user_id
WHERE u.status = 'active';

-- Альтернативный вариант с LIMIT для пагинации:
SELECT u.*, o.total_amount
FROM users u
JOIN LATERAL (
    SELECT total_amount
    FROM orders
    WHERE user_id = u.id
    ORDER BY created_at DESC
    LIMIT 1
) o ON true
WHERE u.status = 'active';
```

**Ключевые улучшения:**
1. Добавлены **частичный индекс** на `users.status` (сокращает объем сканирования).
2. Индекс на `(user_id, created_at)` ускоряет `JOIN` и сортировку.
3. Использован **подзапрос с `LIMIT`** для выборки только последнего заказа (если это бизнес-требование).
4. Альтернативный вариант с `LATERAL JOIN` для более гибкой пагинации.

---

## **Распространенные ошибки**

### **1. Переопределение vs. Недоопределение**

| Ошибка               | Пример prompt                          | Последствия                                  | Как исправить                                  |
|----------------------|----------------------------------------|---------------------------------------------|-----------------------------------------------|
| **Переопределение**  | "Напиши функцию на Python, которая принимает строку, разбивает по пробелам, возвращает список, где каждый элемент — длина слова" | Модель лишена творчества, код может быть неоптимальным | Оставить пространство для интерпретации: "Реализуй функцию для анализа текста, которая возвращает длины слов. Используй Python, но предложи альтернативы, если разделитель не пробел." |
| **Недоопределение**  | "Сделай что-то для обработки данных"   | Нерелевантный или слишком общий ответ       | Добавить контекст: "Реализуй ETL-пайплайн для обработки логов веб-сервера. Требования: парсинг JSON-логов, агрегация по IP, сохранение в ClickHouse." |

### **2. Игнорирование контекста**

**Ошибка:** Не предоставлять контекст о предметной области или ограничениях.

**Пример:**
```plaintext
Напиши функцию для расчета налогов.
```
**Проблема:** Налоги зависят от юрисдикции, ставок, типов дохода. Модель предложит обобщенное решение, которое не подойдет для конкретного случая.

**Исправление:**
```plaintext
Реализуй функцию для расчета подоходного налога в США для 2023 года.
Требования:
- Учитывай стандартные вычеты и прогрессивную шкалу налогообложения.
- Входные данные: годовой доход (float), статус налогоплательщика (string: "single", "married", etc.).
- Возвращай сумму налога и эффективную налоговую ставку.
- Используй актуальные данные IRS (если они известны модели).
```

### **3. Чрезмерное использование ограничений**

**Ошибка:** Задавать слишком много жестких ограничений, которые подавляют креативность.

**Пример:**
```plaintext
Напиши функцию на Python с именем `calc_tax`, которая:
- Принимает 1 аргумент `income` типа float.
- Возвращает число типа float.
- Использует формулу `tax = income * 0.2`.
- Не использует циклы и условия.
- Должна быть не более 3 строк.
```
**Проблема:** Избыточные ограничения делают код негибким и нереалистичным.

**Исправление:**
Реализуй функцию расчета налогов с гибкими параметрами.

---

## 4.3. Few-Shot: Передача паттернов через примеры

### Введение раздела

В предыдущих разделах мы рассмотрели базовые принципы формирования промптов (Zero-Shot) и работу с контекстом (One-Shot). Однако в реальной практике Vibe-Coding часто требуется передавать не просто общие инструкции, а конкретные паттерны поведения, стиля или архитектурных решений. Именно здесь на помощь приходит техника **Few-Shot prompting** — метод, позволяющий обучать Coder-LLM через **несколько примеров**, демонстрирующих желаемое поведение.

Если Zero-Shot — это попытка объяснить задачу "на пальцах", а One-Shot — показать один образец, то Few-Shot — это **полноценное обучение через демонстрацию**. Эта техника особенно эффективна в ситуациях, когда:
- Требуется воспроизвести сложный стиль кодирования (например, корпоративные стандарты).
- Нужно передать неявные правила (например, предпочтительные подходы к обработке ошибок).
- Необходимо обучить модель генерировать код с определенной структурой (например, функциональный стиль против объектно-ориентированного).

В этом разделе мы разберем:
1. Теоретические основы Few-Shot prompting и его отличие от Zero-Shot и One-Shot.
2. Как правильно подбирать примеры для максимальной эффективности.
3. Практические кейсы применения Few-Shot в реальных задачах.
4. Типичные ошибки и способы их избежания.
5. Практические задания для закрепления навыков.

**Почему это важно?**
В традиционном программировании разработчики учатся на примерах: разбирают чужой код, изучают паттерны проектирования, адаптируют решения под свои задачи. Few-Shot prompting переносит этот подход в работу с Coder-LLM, позволяя **масштабировать экспертизу** и быстро передавать лучшие практики.

---

## **Основная теория**

### **1. Что такое Few-Shot prompting?**
**Few-Shot prompting** — это метод обучения модели через предоставление **нескольких примеров** (обычно от 2 до 10), демонстрирующих желаемый выход. В отличие от Zero-Shot (где модель действует на основе общих знаний) и One-Shot (где дается один пример), Few-Shot позволяет **явно задать паттерны** и ожидаемое поведение.

#### **Ключевые характеристики Few-Shot:**
| Характеристика          | Описание                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| **Число примеров**      | Обычно 2–10, но может варьироваться в зависимости от сложности задачи.   |
| **Цель**                | Передать неявные правила, стиль или архитектурные паттерны.             |
| **Эффективность**       | Выше, чем у Zero-Shot и One-Shot для сложных задач.                      |
| **Гибкость**            | Позволяет адаптировать модель под специфические требования.              |

#### **Когда использовать Few-Shot?**
Few-Shot prompting наиболее эффективен в следующих сценариях:
1. **Стилизация кода** (например, соответствие корпоративным стандартам).
2. **Сложные архитектурные решения** (например, реализация паттерна "Репозиторий").
3. **Неявные требования** (например, "используй функциональный стиль без побочных эффектов").
4. **Мультиязычные задачи** (например, генерация кода на нескольких языках с единой логикой).

**Внимание!**
Few-Shot не заменяет глубокого понимания задачи, а лишь **направляет модель** в нужное русло. Примеры должны быть **репрезентативными** и покрывать ключевые случаи.

---

### **2. Исторический контекст и научные основы**
Идея Few-Shot обучения не нова и берет начало в **машинном обучении** и **обучении с подкреплением**. В контексте языковых моделей этот подход был популяризирован работами:
- **GPT-3 (2020)** — первые эксперименты с Few-Shot prompting показали, что модель может обобщать паттерны из небольшого числа примеров.
- **Chain-of-Thought (2022)** — развитие идеи Few-Shot для сложных рассуждений.
- **Meta-Learning** — методы обучения моделей быстро адаптироваться к новым задачам.

#### **Почему Few-Shot работает?**
1. **Модели обучаются на паттернах** — даже небольшое число примеров позволяет выявить общие закономерности.
2. **Контекстное обучение** — модель использует примеры как "подсказки" для генерации похожего выхода.
3. **Обобщение через аналогии** — если в примерах используется определенный стиль, модель склонна его воспроизводить.

**Сравнение с традиционными подходами:**
| Подход               | Традиционное программирование                          | Vibe-Coding (Few-Shot)                          |
|----------------------|--------------------------------------------------------|-------------------------------------------------|
| **Способ обучения**  | Изучение документации, разбор кода, менторство.        | Демонстрация примеров через промпты.            |
| **Скорость адаптации** | Медленно (дни/недели).                                 | Быстро (минуты/часы).                           |
| **Гибкость**         | Требует переписывания кода под новые требования.       | Легко адаптируется через изменение примеров.    |
| **Масштабируемость** | Ограничена числом разработчиков.                       | Позволяет тиражировать экспертизу.              |

---

### **3. Как правильно подбирать примеры?**
Выбор примеров — ключевой фактор успеха Few-Shot prompting. Некачественные примеры могут привести к:
- Генерации нерелевантного кода.
- Нарушению стиля или архитектуры.
- Избыточной сложности решения.

#### **Критерии качественных примеров:**
1. **Репрезентативность** — примеры должны покрывать ключевые случаи задачи.
2. **Разнообразие** — включайте как простые, так и сложные варианты.
3. **Консистентность** — стиль и подход должны быть единообразны.
4. **Краткость** — примеры не должны быть избыточными (избегайте лишних деталей).

#### **Пример плохого и хорошего набора примеров:**
| Плохой пример                          | Хороший пример                          |
|----------------------------------------|-----------------------------------------|
| Пример 1: Слишком простая функция.     | Пример 1: Базовая функция.              |
| Пример 2: Функция с другим стилем.     | Пример 2: Функция с обработкой ошибок.  |
| Пример 3: Функция с лишними зависимостями. | Пример 3: Функция с логгированием.  |

---

### **4. Метафоры для понимания Few-Shot**
Чтобы лучше понять Few-Shot, проведем аналогию с обучением человека:
- **Zero-Shot** — как попросить художника нарисовать картину по описанию ("Нарисуй пейзаж с горами").
- **One-Shot** — показать одну фотографию и попросить нарисовать похожую.
- **Few-Shot** — показать **несколько картин в одном стиле** и попросить создать что-то в этом же духе.

Другая метафора — **обучение ребенка рисовать**:
- Если показать только одну букву "А", ребенок может нарисовать ее по-разному.
- Если показать **несколько вариантов написания "А"**, ребенок с большей вероятностью воспроизведет общий стиль.

---

## **Практические примеры**

### **Пример 1: Стандартизация стиля кода**
**Задача:** Настроить модель генерировать код в соответствии с корпоративными стандартами (например, Google Java Style Guide).

**Zero-Shot подход (неэффективный):**
```plaintext
Напиши функцию на Java, которая сортирует список строк по длине.
Используй стиль Google Java Style Guide.
```
*Проблема:* Модель может не знать всех нюансов стиля.

**Few-Shot подход (эффективный):**
```plaintext
Примеры кода в стиле Google Java Style Guide:

Пример 1:
```java
public final class StringSorter {
  private StringSorter() {}

  public static List<String> sortByLength(List<String> strings) {
    List<String> sorted = new ArrayList<>(strings);
    sorted.sort(Comparator.comparingInt(String::length));
    return sorted;
  }
}
```

Пример 2:
```java
public final class MathUtils {
  private MathUtils() {}

  public static int factorial(int n) {
    if (n < 0) {
      throw new IllegalArgumentException("n must be non-negative");
    }
    int result = 1;
    for (int i = 2; i <= n; i++) {
      result *= i;
    }
    return result;
  }
}
```

Теперь напиши функцию, которая объединяет две строки с разделителем:
```

**Результат:**
Модель сгенерирует код в том же стиле:
```java
public final class StringUtils {
  private StringUtils() {}

  public static String joinWithDelimiter(String a, String b, String delimiter) {
    return a + delimiter + b;
  }
}
```

**Почему это работает?**
- Модель видит **единообразный стиль** (приватные конструкторы, static методы, именование).
- Примеры демонстрируют **типовые паттерны** (утилитные классы, обработка ошибок).

---

### **Пример 2: Реализация паттерна "Репозиторий"**
**Задача:** Научить модель генерировать код для паттерна "Репозиторий" в C#.

**Zero-Shot подход (неэффективный):**
```plaintext
Реализуй паттерн "Репозиторий" для работы с пользователями в C#.
```
*Проблема:* Модель может сгенерировать решение, не соответствующее лучшим практикам.

**Few-Shot подход (эффективный):**
```plaintext
Примеры реализации паттерна "Репозиторий":

Пример 1:
```csharp
public interface IUserRepository
{
    Task<User> GetByIdAsync(int id);
    Task<IEnumerable<User>> GetAllAsync();
    Task AddAsync(User user);
    Task UpdateAsync(User user);
    Task DeleteAsync(int id);
}

public class UserRepository : IUserRepository
{
    private readonly AppDbContext _context;

    public UserRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<User> GetByIdAsync(int id)
    {
        return await _context.Users.FindAsync(id);
    }

    // Другие методы...
}
```

Пример 2:
```csharp
public interface IProductRepository
{
    Task<Product> GetByIdAsync(int id);
    Task<IEnumerable<Product>> GetByCategoryAsync(string category);
}

public class ProductRepository : IProductRepository
{
    private readonly AppDbContext _context;

    public ProductRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Product> GetByIdAsync(int id)
    {
        return await _context.Products
            .Include(p => p.Category)
            .FirstOrDefaultAsync(p => p.Id == id);
    }
}
```

Теперь реализуй паттерн "Репозиторий" для сущности "Order".
```

**Результат:**
Модель сгенерирует код с аналогичной структурой:
```csharp
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task<IEnumerable<Order>> GetByCustomerIdAsync(int customerId);
    Task AddAsync(Order order);
}

public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;

    public OrderRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Order> GetByIdAsync(int id)
    {
        return await _context.Orders
            .Include(o => o.Customer)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
}
```

**Почему это работает?**
- Примеры демонстрируют **ключевые элементы паттерна** (интерфейс, методы, Dependency Injection).
- Модель обобщает структуру и применяет ее к новой сущности.

---

### **Пример 3: Генерация тестов с определенным стилем**
**Задача:** Настроить модель писать модульные тесты в стиле **Behavior-Driven Development (BDD)**.

**Zero-Shot подход (неэффективный):**
```plaintext
Напиши тесты для функции sum(a, b).
```
*Проблема:* Тесты могут быть написаны в произвольном стиле.

**Few-Shot подход (эффективный):**
```plaintext
Примеры тестов в стиле BDD:

Пример 1:
```python
def test_sum_of_two_positive_numbers():
    # Given
    a = 2
    b = 3

    # When
    result = sum(a, b)

    # Then
    assert result == 5
```

Пример 2:
```python
def test_sum_with_zero():
    # Given
    a = 0
    b = 5

    # When
    result = sum(a, b)

    # Then
    assert result == 5
```

Пример 3:
```python
def test_sum_of_negative_numbers():
    # Given
    a = -1
    b = -2

    # When
    result = sum(a, b)

    # Then
    assert result == -3
```

Теперь напиши тесты для функции multiply(a, b).
```

**Результат:**
Модель сгенерирует тесты в том же стиле:
```python
def test_multiply_two_positive_numbers():
    # Given
    a = 2
    b = 3

    # When
    result = multiply(a, b)

    # Then
    assert result == 6

def test_multiply_by_zero():
    # Given
    a = 5
    b = 0

    # When
    result = multiply(a, b)

    # Then
    assert result == 0
```

---

### **Пример 4: Мультиязычная генерация кода**
**Задача:** Настроить модель генерировать аналогичный код на разных языках.

**Zero-Shot подход (неэффективный):**
```plaintext
Напиши функцию для расчета факториала на Python и JavaScript.
```
*Проблема:* Стили реализации могут сильно отличаться.

**Few-Shot подход (эффективный):**
```plaintext
Примеры реализации факториала на разных языках с единым стилем:

Python:
```python
def factorial(n: int) -> int:
    if n < 0:
        raise ValueError("n must be non-negative")
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```

JavaScript:
```javascript
function factorial(n) {
    if (n < 0) {
        throw new Error("n must be non-negative");
    }
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

Теперь напиши реализацию факториала на Go.
```

**Результат:**
Модель сохранит единый стиль:
```go
func factorial(n int) (int, error) {
    if n < 0 {
        return 0, errors.New("n must be non-negative")
    }
    result := 1
    for i := 2; i <= n; i++ {
        result *= i
    }
    return result, nil
}
```

---

### **Пример 5: Обработка ошибок по корпоративным стандартам**
**Задача:** Научить модель обрабатывать ошибки в соответствии с корпоративными требованиями.

**Zero-Shot подход (неэффективный):**
```plaintext
Напиши функцию для чтения файла с обработкой ошибок.
```
*Проблема:* Модель может использовать произвольные подходы к обработке ошибок.

**Few-Shot подход (эффективный):**
```plaintext
Примеры обработки ошибок по корпоративным стандартам:

Пример 1 (Python):
```python
def read_file(file_path: str) -> str:
    try:
        with open(file_path, "r") as file:
            return file.read()
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise FileProcessingError("File not found") from None
    except PermissionError:
        logger.error(f"Permission denied: {file_path}")
        raise FileProcessingError("Permission denied") from None
```

Пример 2 (JavaScript):
```javascript
async function readFile(filePath) {
    try {
        return await fs.promises.readFile(filePath, "utf-8");
    } catch (error) {
        if (error.code === "ENOENT") {
            logger.error(`File not found: ${filePath}`);
            throw new FileProcessingError("File not found");
        } else if (error.code === "EACCES") {
            logger.error(`Permission denied: ${filePath}`);
            throw new FileProcessingError("Permission denied");
        }
        throw error;
    }
}
```

Теперь напиши функцию для парсинга JSON с аналогичной обработкой ошибок на Python.
```

**Результат:**
Модель воспроизведет корпоративный стиль:
```python
def parse_json(json_str: str) -> dict:
    try:
        return json.loads(json_str)
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON: {json_str}")
        raise DataProcessingError("Invalid JSON") from e
    except TypeError:
        logger.error("Input must be a string")
        raise DataProcessingError("Input must be a string") from None
```

---

## **Сравнительная таблица подходов**
| Критерий               | Zero-Shot               | One-Shot                | Few-Shot                |
|------------------------|-------------------------|-------------------------|-------------------------|
| **Число примеров**     | 0                       | 1                       | 2–10                    |
| **Сложность задач**    | Простые                 | Средние                 | Сложные                 |
| **Консистентность**    | Низкая                  | Средняя                 | Высокая                 |
| **Гибкость**           | Высокая                 | Средняя                 | Низкая (зависит от примеров) |
| **Примеры использования** | Быстрые эксперименты  | Демонстрация базового подхода | Стандартизация стиля, передача паттернов |

---

## **Распространенные ошибки**

### **1. Использование нерепрезентативных примеров**
**Проблема:** Если примеры не покрывают ключевые случаи, модель может генерировать некорректный код.

**Пример ошибки:**
```plaintext
Примеры функций для суммирования чисел:

Пример 1: sum(1, 2) -> 3
Пример 2: sum(-1, 1) -> 0
```
*Чего не хватает:*
- Примеров с большими числами (переполнение).
- Примеров с плавающей точкой.
- Обработки ошибок (например, `sum("a", 1)`).

**Как исправить:**
- Включайте **разнообразные случаи** (граничные, ошибочные).
- Проверяйте, что примеры покрывают **все ключевые сценарии**.

---

### **2. Избыточные или противоречивые примеры**
**Проблема:** Если примеры содержат противоречия или лишние детали, модель может запутаться.

**Пример ошибки:**

Пример 1:
```python
def sum(a, b):
    return a + b  # Простая реализация
```

Пример 2:
```python
def sum(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Arguments must be numbers")
    return a + b  # Реализация с проверкой типов
```

*Проблема:* Примеры противоречат друг другу (один без проверки типов, другой с проверкой).

**Как исправить:**
- Убедитесь, что все примеры **консистентны**.
- Избегайте лишних деталей, которые не нужны для задачи.

---

### **3. Слишком сложные примеры**
**Проблема:** Если примеры слишком сложные, модель может не обобщить паттерн.

**Пример ошибки:**
```plaintext
Пример: Реализация полноценного REST API с авторизацией, кэшированием и пагинацией.
```
*Проблема:* Модель может сфокусироваться на нерелевантных деталях (например, настройка кэша), а не на основной задаче.

**Как исправить:**
- Делите сложные примеры на **несколько простых**.
- Сначала обучите модель на базовых случаях, затем добавляйте сложность.

---

### **4. Недостаточное число примеров**
**Проблема:** Слишком мало примеров могут не дать модели достаточно контекста.

**Пример ошибки:**
```plaintext
Пример: Только одна реализация функции.
```
*Проблема:* Модель может не понять общий паттерн.

**Как исправить:**
- Используйте **минимум 2–3 примера** для Few-Shot.
- Если задача сложная, увеличивайте число примеров.

---

## **Практические задания**

### **Задание 1: Стандартизация стиля кода**
**Цель:** Научиться передавать корпоративные стандарты через Few-Shot.

**Инструкция:**
1. Выберите язык программирования (например, Python или Java).
2. Подготовьте **3 примера** кода в корпоративном стиле (например, именование переменных, обработка ошибок).
3. Попросите модель сгенерировать новую функцию в том же стиле.
4. Проверьте, что:
   - Код соответствует стандартам.
   - Обработка ошибок выполнена корректно.
   - Именование переменных единообразно.

**Пример для проверки:**
```python
# Примеры стиля:
def calculate_discount(price, discount_percent):
    if not (0 <= discount_percent <= 100):
        raise ValueError("Discount must be between 0 and 100")
    return price * (1 - discount_percent / 100)

def apply_tax(price, tax_rate):
    if tax_rate < 0:
        raise ValueError("Tax rate cannot be negative")
    return price * (1 + tax_rate)

# Задание: Напиши функцию для расчета итоговой стоимости товара с учетом скидки и налога.
```

---

### **Задание 2: Реализация паттерна "Стратегия"**
**Цель:** Научиться передавать архитектурные паттерны через Few-Shot.

**Инструкция:**
1. Подготовьте **2 примера** реализации паттерна "Стратегия" на любом языке.
2. Попросите модель реализовать аналогичный паттерн для новой задачи (например, сортировка строк разными способами).
3. Проверьте, что:
   - Интерфейс стратегии реализован корректно.
   - Контекст правильно делегирует выполнение стратегии.
   - Код соответствует принципам SOLID.

**Пример для проверки:**
```java
// Примеры стратегий:
interface SortStrategy {
    void sort(String[] array);
}

class LexicographicalSort implements SortStrategy {
    @Override
    public void sort(String[] array) {
        Arrays.sort(array);
    }
}

class LengthSort implements SortStrategy {
    @Override
    public void sort(String[] array) {
        Arrays.sort(array, Comparator.comparingInt(String::length));
    }
}

// Задание: Реализуй паттерн "Стратегия" для сортировки по количеству гласных.
```

---

### **Задание 3: Мультиязычная генерация кода**
**Цель:** Научиться генерировать аналогичный код на разных языках.

**Инструкция:**
1. Подготовьте **2 примера** функции на двух разных языках (например, Python и JavaScript).
2. Попросите модель реализовать ту же функцию на третьем языке (например, Go или Rust).
3. Проверьте, что:
   - Логика функции сохранена.
   - Стиль соответствует примерам.

**Пример для проверки:**
```python
# Python:
def is_palindrome(s):
    return s == s[::-1]
```

```javascript
// JavaScript:
function isPalindrome(s) {
    return s === s.split("").reverse().join("");
}
```

```plaintext
// Задание: Реализуй is_palindrome на Rust.
```

---

В этом разделе мы глубоко погрузились в технику **Few-Shot prompting** — мощный инструмент для передачи паттернов и стилей.

---

## 4.4. Thought: Заставляем ИИ «думать вслух» перед написанием кода

### Введение раздела

В традиционном программировании разработчик сначала продумывает алгоритм, затем реализует его в коде. При взаимодействии с Coder-LLM этот процесс часто сжимается до одной фразы: *«Напиши функцию, которая делает X»*. Однако такой подход не всегда эффективен — особенно в сложных задачах, где требуется учет множества нюансов.

**Thought** (рус. *«размышление»*) — это техника Vibe-Coding, при которой мы заставляем модель **вслух проговаривать этапы решения задачи перед написанием кода**. Вместо того чтобы сразу генерировать готовый ответ, ИИ разбивает задачу на логические шаги, оценивает возможные подходы и только потом приступает к реализации.

Этот раздел посвящен тому, как и почему **предварительное «размышление» ИИ** снижает количество ошибок, улучшает качество кода и делает взаимодействие с моделью более прозрачным. Мы рассмотрим:
- **Теоретическую основу** техники Thought и ее отличие от прямого запроса кода.
- **Практические примеры** с пошаговыми инструкциями.
- **Типичные ошибки** и способы их избежать.
- **Задания для самостоятельной работы**, которые помогут закрепить материал.

Если в предыдущих разделах мы изучали базовые элементы Vibe-Coding (контекст, интенции, декомпозицию), то теперь переходим к более **продвинутой стратегии**, позволяющей контролировать не только конечный результат, но и сам процесс мышления ИИ.

---

## **Основная теория**

### **1. Почему «размышление вслух» работает?**
В основе техники **Thought** лежит **когнитивная архитектура современных LLM**, которая имитирует процесс человеческого мышления через последовательность токенов. Когда модель «обдумывает задачу», она фактически генерирует промежуточные шаги, которые помогают:
- **Снизить неопределенность**: ИИ сам формулирует ограничения и предположения, вместо того чтобы угадывать их из краткого запроса.
- **Выявить скрытые проблемы**: Многие ошибки в коде возникают из-за неявных допущений (например, работа с граничными случаями). Thought заставляет модель их проговаривать.
- **Улучшить качество кода**: Разбивая задачу на этапы, ИИ чаще выбирает оптимальные алгоритмы.

#### **Сравнение с традиционным подходом**
| **Традиционный запрос** | **Запрос с Thought** |
|-------------------------|----------------------|
| *«Напиши функцию для сортировки списка»* | *«Объясни, как бы ты реализовал сортировку списка. Учти: список может содержать дубликаты, а производительность критична. После объяснения напиши код.»* |
| **Результат**: Код может быть неоптимальным (например, O(n²) вместо O(n log n)), так как модель не учла контекст. | **Результат**: ИИ сначала анализирует возможные подходы (бинарная сортировка? quicksort?), сравнивает их и только потом пишет код. |

**Метафора**:
Представьте, что вы просите коллегу решить задачу. Если он сразу начинает писать код, велик риск ошибок. Но если он сначала расскажет план («Сначала я проверю входные данные, потом применю фильтр, затем отсортирую»), вы сможете вовремя скорректировать его подход.

### **2. Как устроено «мышление» ИИ?**
Модели не «думают» в человеческом смысле — они **генерируют текст на основе вероятностей**. Однако техника Thought использует этот механизм для:
- **Декомпозиции задачи**: ИИ разбивает сложную задачу на подзадачи.
- **Генерации гипотез**: Модель предлагает несколько вариантов решения и выбирает лучший.
- **Самопроверки**: Проговаривая шаги, ИИ может обнаружить логические противоречия.

#### **Пример внутреннего процесса ИИ**
Запрос:
*«Как бы ты реализовал функцию для поиска кратчайшего пути в графе?»*

Ответ модели (Thought-этап):
1. **Анализ задачи**:
   - Граф может быть взвешенным/невзвешенным.
   - Нужно учитывать направленность ребер.
   - Входные данные: матрица смежности или список ребер?
2. **Выбор алгоритма**:
   - Если граф невзвешенный → BFS.
   - Если есть отрицательные веса → Беллман-Форд.
   - Иначе → Дейкстра (с приоритетной очередью).
3. **Оценка ограничений**:
   - Память: для больших графов лучше использовать список смежности.
   - Производительность: O(V + E) для BFS, O(E log V) для Дейкстры.
4. **Реализация**:
   *«Я выберу алгоритм Дейкстры, так как граф взвешенный, а отрицательных весов нет. Буду использовать приоритетную очередь для оптимизации.»*

### **3. Когда использовать Thought?**
Техника особенно полезна в следующих случаях:
✅ **Сложные алгоритмы** (например, графы, динамическое программирование).
✅ **Задачи с неявными ограничениями** (работа с большими данными, многопоточность).
✅ **Отладка**: Если код работает некорректно, можно попросить модель **«объяснить, как она его писала»**.
✅ **Оптимизация кода**: Просьба *«Объясни, почему ты выбрал этот подход, и предложи альтернативы»* помогает найти лучшее решение.

### **4. Исторический контекст: от «черного ящика» к прозрачности**
Ранние версии LLM (например, GPT-2) часто давали **прямые ответы без объяснений**, что приводило к ошибкам из-за несоответствия контекста. С развитием моделей (GPT-3, Claude, Gemini) стало возможным **управлять процессом генерации**, требуя от ИИ «обоснований».

Thought — это часть более широкого тренда **«объяснимого ИИ» (Explainable AI, XAI)**, где ключевым требованием является прозрачность принятия решений.

---

## **Практические примеры**

### **Пример 1: Оптимизация функции поиска**
**Задача**: Написать функцию, которая ищет все вхождения подстроки в строке.

#### **Плохой запрос (без Thought)**
```plaintext
Напиши функцию на Python, которая находит все вхождения подстроки в строке.
```
**Результат ИИ (возможный вариант)**:
```python
def find_substring(text, substring):
    return [i for i in range(len(text)) if text[i:i+len(substring)] == substring]
```
**Проблемы**:
- Работает за O(n*m), что неэффективно для больших строк.
- Не учитывает edge cases (например, пустая подстрока).

#### **Хороший запрос (с Thought)**
```plaintext
Объясни, как бы ты реализовал функцию поиска всех вхождений подстроки в строке.
Учти:
- Производительность (большие тексты).
- Обработку edge cases (пустая подстрока, регистрозависимость).
После объяснения напиши код.
```

**Результат ИИ (Thought-этап)**:
1. **Анализ задачи**:
   - Для больших текстов нужен алгоритм лучше, чем наивный (O(n²)).
   - Можно использовать **алгоритм Кнута-Морриса-Пратта (KMP)** или **построение суффиксного автомата**.
2. **Выбор алгоритма**:
   - KMP эффективен (O(n + m)), но сложнее в реализации.
   - Для простоты возьмем **встроенную функцию `str.find`** в цикле (в Python она оптимизирована на C).
3. **Обработка edge cases**:
   - Пустая подстрока → вернуть пустой список.
   - Регистрозависимость → добавить флаг `case_sensitive`.
4. **Оптимизация**:
   - Использовать генератор для экономии памяти.

**Итоговый код**:
```python
def find_substring(text, substring, case_sensitive=True):
    if not substring:
        return []
    if not case_sensitive:
        text = text.lower()
        substring = substring.lower()
    start = 0
    len_sub = len(substring)
    while True:
        pos = text.find(substring, start)
        if pos == -1:
            break
        yield pos
        start = pos + 1

# Пример использования
text = "Hello hello world"
print(list(find_substring(text, "hello", case_sensitive=False)))
# Вывод: [0, 6]
```

**Сравнительная таблица**:
| Критерий          | Без Thought               | С Thought                          |
|-------------------|---------------------------|------------------------------------|
| Производительность| O(n²)                     | O(n) (использование `str.find`)    |
| Edge cases        | Не учтены                 | Учтена пустая подстрока, регистр   |
| Код               | Простой, но неоптимальный | Эффективный и гибкий              |

---

### **Пример 2: Реализация кэширования**
**Задача**: Написать функцию с кэшированием результатов (мемоизация).

#### **Запрос без Thought**
```plaintext
Напиши функцию на Python с кэшированием.
```
**Результат ИИ**:
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```
**Проблемы**:
- Не объяснено, почему выбран `lru_cache`.
- Не учтены ограничения (например, неизменяемые аргументы).
- Нет обработки ошибок (например, отрицательные числа).

#### **Запрос с Thought**
```plaintext
Объясни, как бы ты реализовал функцию с кэшированием результатов.
Учти:
- Тип данных аргументов (хешируемые?).
- Ограничения по памяти.
- Возможность сброса кэша.
После объяснения напиши код.
```

**Результат ИИ (Thought-этап)**:
1. **Анализ задачи**:
   - Кэширование нужно для **функций с дорогими вычислениями**.
   - Аргументы должны быть **хешируемыми** (например, не `list`, а `tuple`).
2. **Выбор подхода**:
   - `lru_cache` удобен, но не подходит для динамического управления кэшом.
   - Можно использовать **ручное кэширование с `dict`** для большего контроля.
3. **Обработка edge cases**:
   - Нехешируемые аргументы → конвертировать в хешируемый формат.
   - Ограничение памяти → добавить `maxsize`.
4. **Дополнительные возможности**:
   - Метод для сброса кэша (`clear_cache`).

**Итоговый код**:
```python
from functools import wraps

def memoize(maxsize=128):
    def decorator(func):
        cache = {}

        @wraps(func)
        def wrapper(*args):
            # Конвертируем аргументы в хешируемый формат
            key = args
            if not isinstance(key, (int, float, str, tuple)):
                key = str(args)

            if key in cache:
                return cache[key]

            result = func(*args)
            if len(cache) >= maxsize:
                cache.pop(next(iter(cache)))  # Удаляем самый старый элемент
            cache[key] = result
            return result

        def clear_cache():
            cache.clear()

        wrapper.clear_cache = clear_cache
        return wrapper
    return decorator

# Пример использования
@memoize(maxsize=100)
def expensive_function(x, y):
    print(f"Computing for {x}, {y}")  # Для демонстрации
    return x * y + 2 * x

print(expensive_function(2, 3))  # Выведет: Computing for 2, 3 → 8
print(expensive_function(2, 3))  # Возьмет из кэша → 8
expensive_function.clear_cache()  # Сбросить кэш
```

---

### **Пример 3: Работа с API**
**Задача**: Написать функцию для запроса данных с API с обработкой ошибок.

#### **Запрос без Thought**
```plaintext
Напиши функцию на Python для запроса данных с API.
```
**Результат ИИ**:
```python
import requests

def get_api_data(url):
    response = requests.get(url)
    return response.json()
```
**Проблемы**:
- Нет обработки ошибок (например, 404, 500).
- Нет тайм-аута.
- Нет проверки `response.status_code`.

#### **Запрос с Thought**
```plaintext
Объясни, как бы ты реализовал функцию для запроса данных с API.
Учти:
- Обработку HTTP-ошибок (4xx, 5xx).
- Тайм-ауты и повторные попытки.
- Парсинг JSON с валидацией.
После объяснения напиши код.
```

**Результат ИИ (Thought-этап)**:
1. **Анализ задачи**:
   - Нужно учитывать **разные статусы ответов** (200, 404, 500).
   - API может быть **медленным или недоступным** → нужен тайм-аут.
2. **Обработка ошибок**:
   - Повторные попытки при 5xx (серверные ошибки).
   - Игнорировать 4xx (клиентские ошибки) или логировать их.
3. **Безопасность**:
   - Тайм-аут, чтобы избежать зависания.
   - Проверка `response.status_code`.
4. **Дополнительно**:
   - Валидация JSON (может быть невалидным).

**Итоговый код**:
```python
import requests
from requests.exceptions import RequestException, Timeout
import json

def get_api_data(url, max_retries=3, timeout=10):
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=timeout)
            response.raise_for_status()  # Выбросит исключение для 4xx/5xx
            try:
                return response.json()
            except json.JSONDecodeError:
                raise ValueError("Invalid JSON response")
        except Timeout:
            if attempt == max_retries - 1:
                raise Timeout(f"API request timed out after {max_retries} attempts")
        except RequestException as e:
            if attempt == max_retries - 1:
                raise RequestException(f"API request failed: {str(e)}")
    return None  # На случай, если все попытки исчерпаны

# Пример использования
try:
    data = get_api_data("https://api.example.com/data", max_retries=2)
    print(data)
except Exception as e:
    print(f"Error: {e}")
```

---

### **Пример 4: Генерация тестов**
**Задача**: Написать тесты для функции с использованием `unittest`.

#### **Запрос без Thought**
```plaintext
Напиши тесты для функции `add(a, b)`.
```
**Результат ИИ**:
```python
import unittest

def add(a, b):
    return a + b

class TestAdd(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
```
**Проблемы**:
- Тесты не покрывают edge cases (отрицательные числа, строки).
- Нет проверки на тип данных.

#### **Запрос с Thought**
```plaintext
Объясни, какие тесты нужно написать для функции `add(a, b)`.
Учти:
- Разные типы данных (числа, строки).
- Edge cases (большие числа, отрицательные числа).
- Обработку ошибок (например, сложение int и str).
После объяснения напиши код тестов.
```

**Результат ИИ (Thought-этап)**:
1. **Анализ функции**:
   - Функция `add` может работать с **числами, строками, списками**.
   - Нужно проверить **корректность сложения** и **обработку ошибок**.
2. **Типы тестов**:
   - **Базовые случаи**: `add(2, 3)`, `add("a", "b")`.
   - **Edge cases**: `add(-1, 1)`, `add(1e100, 1e100)`.
   - **Типовые ошибки**: `add(2, "3")` → должно вызывать `TypeError`.
3. **Структура тестов**:
   - Отдельные методы для каждого случая.
   - Использование `assertRaises` для проверки исключений.

**Итоговый код**:
```python
import unittest

def add(a, b):
    if isinstance(a, str) and isinstance(b, str):
        return a + b
    if isinstance(a, (int, float)) and isinstance(b, (int, float)):
        return a + b
    raise TypeError("Unsupported operand types")

class TestAdd(unittest.TestCase):
    def test_numbers(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(1.5, 2.5), 4.0)

    def test_strings(self):
        self.assertEqual(add("a", "b"), "ab")
        self.assertEqual(add("", "test"), "test")

    def test_large_numbers(self):
        self.assertEqual(add(1e100, 1e100), 2e100)

    def test_type_error(self):
        with self.assertRaises(TypeError):
            add(2, "3")
        with self.assertRaises(TypeError):
            add([1, 2], 3)

if __name__ == "__main__":
    unittest.main()
```

---

### **Пример 5: Рефакторинг кода**
**Задача**: Улучшить существующий код с помощью Thought.

#### **Исходный код (плохой пример)**
```python
def process_data(data):
    result = []
    for item in data:
        if item["type"] == "A":
            result.append(item["value"] * 2)
        elif item["type"] == "B":
            result.append(item["value"] + 10)
        else:
            result.append(item["value"])
    return result
```

#### **Запрос с Thought**
```plaintext
Объясни, как можно улучшить этот код. Учти:
- Читаемость и поддержку.
- Возможность добавления новых типов обработки.
- Производительность (если данных много).
После объяснения перепиши код.
```

**Результат ИИ (Thought-этап)**:
1. **Анализ проблем**:
   - Жестко закодированные условия (`if-elif-else`) плохо масштабируются.
   - Нет обработки отсутствующих ключей (`KeyError`).
2. **Варианты улучшения**:
   - Использовать **словарь функций** для обработки разных типов.
   - Добавить **валидацию входных данных**.
   - Обработать **исключения**.
3. **Оптимизация**:
   - Использовать **генератор** для экономии памяти.
   - Добавить **конфигурацию обработки** в отдельную структуру.

**Улучшенный код**:
```python
def process_data(data):
    # Конфигурация обработки типов
    type_handlers = {
        "A": lambda x: x * 2,
        "B": lambda x: x + 10,
    }

    result = []
    for item in data:
        try:
            value = item["value"]
            handler = type_handlers.get(item.get("type", ""), lambda x: x)
            result.append(handler(value))
        except (KeyError, TypeError):
            result.append(None)  # Или raise, если нужна строгость

    return result

# Пример использования
data = [
    {"type": "A", "value": 5},
    {"type": "B", "value": 3},
    {"type": "C", "value": 10},
    {"value": 7},  # Нет типа
]
print(process_data(data))  # [10, 13, 10, 7]
```

---

## **Распространенные ошибки**

### **1. Слишком общий запрос на Thought**
**Ошибка**:
```plaintext
Объясни, как решить эту задачу.
```
**Проблема**: Модель может дать слишком абстрактный ответ без конкретных шагов.

**Исправление**:
```plaintext
Объясни пошагово, как реализовать функцию сортировки.
Учти:
- Входные данные (список чисел или строк).
- Производительность (O(n log n)).
- Обработку дубликатов.
```

---

### **2. Игнорирование edge cases**
**Ошибка**: Не просить модель учитывать граничные случаи.

**Пример**:
```python
# Плохо: модель может не учесть пустой список
def max_value(arr):
    return max(arr)
```

**Исправление**:
```plaintext
Объясни, как реализовать функцию поиска максимума в списке.
Учти:
- Пустой список (вернуть None).
- Все элементы одинаковые.
- Очень большие числа (переполнение).
```

---

### **3. Недостаточная детализация**
**Ошибка**: Просить объяснить только часть задачи.

**Пример**:
```plaintext
Объясни, как выбрать алгоритм сортировки.
```
(Без просьбы написать код или учесть ограничения.)

**Исправление**:
```plaintext
Объясни, какой алгоритм сортировки выбрать для списка из 1 млн элементов.
Учти:
- Время выполнения.
- Память.
- Стабильность сортировки.
После объяснения напиши код.
```

---

### **4. Переусложнение запроса**
**Ошибка**: Просить модель обдумать слишком много аспектов одновременно.

**Пример**:
```plaintext
Объясни, как реализовать систему кэширования с поддержкой распределенного хранения, инвалидации кэша, мониторинга и автоматического масштабирования.
```
(Модель может запутаться или дать поверхностный ответ.)

**Исправление**:
Разбить на подзадачи:
1. Объясни, как реализовать **локальное кэширование**.
2. Затем добавить **инвалидацию**.
3. После этого рассмотреть **распределенное хранение**.

---

## **Практические задания**

### **Задание 1: Реализация бинарного поиска**
**Задача**:
Напишите запрос с использованием **Thought**, чтобы ИИ реализовал функцию бинарного поиска.
Требования:
- Учитывать edge cases (пустой массив, отсутствие элемента).
- Объяснить, почему выбран именно этот подход.
- Написать тесты с помощью `unittest`.

**Критерии выполнения**:
✅ ИИ сначала объясняет алгоритм.
✅ Код учитывает все edge cases.
✅ Написаны тесты для всех сценариев.

**Пример проверки**:
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Тесты должны покрывать:
# - Пустой массив.
# - Элемент в начале, середине и конце.
# - Отсутствие элемента.
```

---

### **Задание 2: Оптимизация медленной функции**
**Задача**:
Дана функция, которая считает количество уникальных слов в тексте:
```python
def count_unique_words(text):
    words = text.split()
    unique_words = []
    for word in words:
        if word not in unique_words:
            unique_words.append(word)
    return len(unique_words)
```
Используя **Thought**, попросите ИИ:
1. Объяснить, почему эта функция работает медленно.
2. Предложить оптимизацию.
3. Написать улучшенный код.

**Критерии выполнения**:
✅ ИИ объясняет, что сложность O(n²) из-за `in` для списка.
✅ Предлагает использовать `set` (O(n)).
✅ Код учитывает регистр и пунктуацию.

**Пример проверки**:
```python
# ИИ должен сгенерировать:
def count_unique_words_optimized(text):
    import re
    words = re.findall(r'\b\w+\b', text.lower())
    return len(set(words))

# И объяснить:
# 1. O(n²) -> O(n) благодаря set
# 2. re.findall для корректной обработки пунктуации
# 3. .lower() для учёта регистра
```

---

## 4.2. Семантическая точность

# **4.2. Семантическая точность: Как формулировать намеки, не ограничивая креативность, но сохраняя курс**

## **Введение раздела**

В предыдущем разделе мы изучили грамматику смысла — переход от синтаксических правил к семантическому выражению намерений. Однако одна из самых сложных задач в Vibe-Coding — найти **баланс между точностью и гибкостью** запроса.

Представьте, что вы дирижёр оркестра. Слишком строгие указания ("играй ноту до 4 бита ровно 2 секунды") убьют творчество и выразительность. Слишком общие команды ("сыграй что-нибудь грустное") приведут к хаосу. Искусство дирижирования — в точных намёках, которые задают направление, но оставляют пространство для интерпретации.

То же самое в Vibe-Coding: **семантическая точность** — это умение формулировать запросы так, чтобы Coder-LLM понял направление, но сохранил креативность в поиске оптимального решения.

---

## **Основная теория**

### **1. Спектр точности запросов**

#### **1.1. Слишком общие запросы (Under-constrained)**

**Примеры:**
- "Сделай сайт"
- "Напиши код для базы данных"
- "Оптимизируй приложение"

**Проблемы:**
- ИИ не понимает масштаб и требования
- Генерирует слишком общие решения
- Требует множество уточняющих вопросов

**Результат:** Потеря времени на итерации, возможные неверные решения.

#### **1.2. Слишком строгие запросы (Over-constrained)**

**Примеры:**
- "Создай REST API на Express.js с PostgreSQL, используй только async/await, добавь middleware для логирования в формате JSON, включи CORS для localhost:3000, реализуй пагинацию через LIMIT/OFFSET"
- "Напиши функцию сортировки массива пузырьком, используй только цикл for, без рекурсии, с подсчётом итераций"

**Проблемы:**
- Убивает креативность ИИ
- Может предложить неоптимальное решение
- Ограничивает возможность улучшения

#### **1.3. Оптимальная семантическая точность**

**Примеры:**
- "Создай REST API для управления задачами. Важно: хорошая масштабируемость и понятные ошибки. Подумай о выборе базы данных и архитектуре."
- "Напиши функцию сортировки для учебных целей. Покажи несколько алгоритмов и объясни плюсы/минусы каждого."

**Ключевые принципы:**
- Фокус на **целях**, а не на реализации
- Указание **ограничений** и **требований**
- Оставление пространства для **креативных решений**

---

### **2. Техники семантической точности**

#### **2.1. Принцип "Что, Почему, Как"**

**Что (What):** Чёткое описание результата
**Почему (Why):** Контекст и бизнес-цели
**Как (How):** Технические ограничения и предпочтения

**Пример:**
> "Что: Нужен API для загрузки файлов. Почему: Пользователи должны обмениваться большими документами (до 1ГБ). Как: Используй потоковую загрузку, прогресс-бар, проверку форматов. Важно: надёжность и обработка ошибок."

#### **2.2. Метод "Якорь и свободы"**

**Якорь (Anchor):** Обязательные требования
**Свобода (Freedom):** Области для креативности

**Пример:**
> "Якорь: API должен соответствовать OpenAPI 3.0, использовать JWT аутентификацию. Свобода: выбери оптимальную базу данных, архитектуру, методы кэширования."

#### **2.3. Техника "Пример + Контекст"**

Дать пример ожидаемого результата, но оставить путь открытым:

**Пример:**
> "Создай компонент для отображения графика как в TradingView. Нужны: zoom, pan, real-time обновления. Пример данных: [{time: 1234567890, price: 100.5}, ...]. Выбери лучшую библиотеку и подход."

---

## **Практические примеры**

### **Пример 1: Эволюция запроса**

**Начальный запрос (слишком общий):**
> "Сделай чат"

**Итерация 1 (добавляем контекст):**
> "Сделай веб-чат для командной работы. Нужны комнаты, приватные сообщения, уведомления."

**Итерация 2 (добавляем требования):**
> "Сделай веб-чат для командной работы. Важно: real-time, история сообщений, уведомления @mentions. Подумай о масштабировании до 1000+ пользователей."

**Итерация 3 (семантическая точность):**
> "Создай real-time чат приложение. Якорь: WebSocket, комнаты, @mentions, история. Свобода: выбери архитектуру (microservices vs monolith), базу данных, фронтенд фреймворк. Учти: offline режим, мобильная адаптация."

**Результат:** ИИ предложит комплексное решение с обоснованием выборов.

### **Пример 2: Рефакторинг с точностью**

**Плохой запрос:**
> "Оптимизируй этот код"

**Хороший запрос:**
> "Этот код работает медленно при больших данных (>100к записей). Проблема в N+1 запросах к базе. Сохраняя текущий API, оптимизируй производительность. Можно: добавить индексы, изменить запросы, использовать кэш. Важно: не сломать существующий функционал."

### **Пример 3: Выбор технологии**

**Слишком строгий:**
> "Используй React, TypeScript, Tailwind CSS, Node.js, PostgreSQL"

**Оптимальный:**
> "Нужен SPA для e-commerce. Требования: SEO friendly, быстрая загрузка, easy deployment. Учти: команда знает JavaScript, но готова учить новое. Предложи и обоснуй стек технологий."

---

## **Продвинутые техники**

### **1. Многоуровневые запросы**

Структурируйте запрос от общего к частному:

```
1. Общая цель: Создать систему аналитики
2. Бизнес-требования: Отслеживание пользовательского поведения
3. Технические ограничения: Работать с существующей базой
4. Детали реализации: Dashboard, real-time графики, export данных
```

### **2. Контр-примеры**

Дайте ИИ примеры того, чего делать НЕ нужно:

> "Создай систему опросов. НЕ используй: Alert, confirm dialogs. Вместо этого используй inline валидацию. Избегай: page reloads, сложных анимаций."

### **3. Метрики качества**

Укажите, как измерять успех:

> "Оптимизируй загрузку страницы. Целевые метрики: LCP < 2.5s, FID < 100ms, CLS < 0.1. Измеряй перед и после оптимизации."

---

## **Распространенные ошибки**

### **Ошибка 1: Микроменеджмент**

**Проблема:** Попытка контролировать каждую деталь реализации.

**Пример:**
> "Используй именно функцию map, не forEach. Добавь console.log после каждой операции. Используй const, не let."

**Решение:** Фокусируйтесь на результате, а не на процессе.

### **Ошибка 2: Недостаточный контекст**

**Проблема:** ИИ не знает бизнес-контекст.

**Пример:**
> "Создай форму регистрации"

**Лучше:**
> "Создай форму регистрации для SaaS продукта. Важно: email верификация, GDPR compliance, enterprise интеграция (SSO)."

### **Ошибка 3: Игнорирование ограничений**

**Проблема:** Не указание реальных ограничений проекта.

**Пример:**
> "Создай нейросеть для распознавания изображений"

**Лучше:**
> "Создай систему распознавания лиц. Ограничения: работает на CPU, модель <50MB, точность >95%. Используй существующие библиотеки."

---

## **Практические задания**

### **Задание 1: Точность vs Креативность**

**Задача:**
Возьмите простую задачу ("создать TODO приложение") и сформулируйте 3 варианта запроса:
1. Слишком общий
2. Слишком строгий  
3. Оптимально точный

Сравните результаты от ИИ.

### **Задание 2: Рефакторинг запроса**

**Задача:**
Улучшите этот запрос:
> "Сделай быстрый сайт"

Добавьте контекст, требования, метрики.

---

## **Заключение раздела**

Семантическая точность — это **искусство баланса** между чёткими требованиями и свободой для творчества. Ключевые выводы:

1. **Фокус на целях**, а не на реализации
2. **Контекст важнее деталей**
3. **Оставляйте пространство для экспертизы ИИ**
4. **Измеряйте результат**, а не процесс

В следующем разделе мы изучим принцип "Дай я покажу" (Few-Shot Learning).

---

## 4.3. Принцип «Дай я покажу» (Few-Shot)

# **4.3. Принцип «Дай я покажу» (Few-Shot): Передача паттернов через примеры**

## **Введение раздела**

В предыдущих разделах мы изучили, как формулировать запросы с оптимальной семантической точностью. Однако даже самые точные описания иногда не могут передать сложные паттерны, стили кодирования или специфические требования. Здесь на помощь приходит **Few-Shot Learning** — техника передачи знаний через примеры.

Представьте, что вы учите кого-то готовить блюдо. Можно подробно описать рецепт: "возьми 200г муки, добавь 100мл воды, соль по вкусу". Но гораздо эффективнее показать: "смотри, как я делаю" — и продемонстрировать весь процесс.

В Vibe-Coding **Few-Shot** — это предоставление ИИ примеров, которые он должен использовать как образец для генерации кода. Этот метод особенно мощен для передачи стиля, архитектурных паттернов и сложных логик.

---

## **Основная теория**

### **1. Почему Few-Shot работает лучше текста?**

#### **1.1. Сила конкретных примеров**

**Текстовое описание:**
> "Создай middleware для Express.js с логированием запросов"

**Few-Shot подход:**
> "Создай middleware для Express.js с логированием запросов. Вот пример того, как мы логируем в проекте:
> ```javascript
> logger.info('Request received', {
>   method: req.method,
>   url: req.url,
>   userAgent: req.get('User-Agent'),
>   timestamp: new Date().toISOString()
> });
> ```
> Используй такой же формат и уровень детализации."

**Почему это работает лучше:**
- ИИ видит **точную структуру** лога
- Понимает **уровень детализации**  
- Соблюдает **форматирование** и **именование полей**

#### **1.2. Передача неявных знаний**

Примеры содержат множество неявных знаний, которые сложно выразить словами:

```javascript
// Пример показывает:
// - Использование async/await вместо колбэков
// - Структуру error handling
// - Формат ответа API
// - Использование деструктуризации
```

#### **1.3. Контекстные паттерны**

Few-Shot позволяет передать сложные паттерны:

**Zero-Shot (плохо):**
> "Напиши функцию валидации пользователя"

**Few-Shot (хорошо):**
> "Напиши функцию валидации пользователя. Вот наши паттерны:
> ```javascript
> // Пример 1: Валидация email
> const validateEmail = (email) => {
>   const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
>   return re.test(email);
> };
> 
> // Пример 2: Валидация пароля
> const validatePassword = (password) => {
>   return password && password.length >= 8;
> };
> ```
> Используй такой же подход: отдельные функции для каждого поля, понятные имена, возврат boolean."

---

### **2. Типы Few-Shot примеров**

#### **2.1. Code Examples (Самые эффективные)**

Показывают конкретный код, который нужно эмулировать:

**Пример для React компонентов:**
```javascript
// Вот как мы создаём компоненты в проекте:
const Button = ({ children, variant, onClick, disabled }) => {
  const baseClass = 'btn';
  const variantClass = variant ? `btn-${variant}` : '';
  const disabledClass = disabled ? 'btn-disabled' : '';
  
  return (
    <button 
      className={`${baseClass} ${variantClass} ${disabledClass}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};

// Создай аналогичный компонент Input с такими же принципами
```

#### **2.2. Input-Output Pairs**

Показывают соотношение входных данных и результатов:

**Пример для форматирования:**
```
Input: "john_doe" -> Output: "John Doe"
Input: "jane_smith" -> Output: "Jane Smith"  
Input: "bob_wilson" -> Output: "Bob Wilson"

Теперь преобразуй: "alice_johnson"
```

#### **2.3. Step-by-Step Examples**

Показывают процесс решения:

**Пример для алгоритма:**
```
Пример 1:
Список: [3, 1, 4, 1, 5, 9, 2, 6]
Шаги: 
1. Создаём множество: {1, 2, 3, 4, 5, 6, 9}
2. Сортируем: [1, 2, 3, 4, 5, 6, 9]
3. Находим дубликаты: 1 встречается 2 раза
Результат: [1]

Пример 2:
Список: [7, 3, 5, 6, 3, 8]
Шаги:
1. Множество: {3, 5, 6, 7, 8}
2. Сортируем: [3, 3, 5, 6, 7, 8]
3. Дубликаты: 3 встречается 2 раза
Результат: [3]

Теперь найди дубликаты в: [2, 4, 5, 2, 8, 1]
```

---

## **Практические примеры**

### **Пример 1: Передача стиля кодирования**

**Задача:** Создать функцию для работы с API

**Запрос с Few-Shot:**
> "Создай функцию для вызова API. Вот наш стиль кодирования:
> ```javascript
> // Пример 1: GET запрос
> const fetchUser = async (userId) => {
>   try {
>     const response = await api.get(`/users/${userId}`);
>     return response.data;
>   } catch (error) {
>     logger.error('Failed to fetch user', { userId, error: error.message });
>     throw new ApiError('User not found', 404);
>   }
> };
> 
> // Пример 2: POST запрос
> const createUser = async (userData) => {
>   try {
>     const response = await api.post('/users', userData);
>     return response.data;
>   } catch (error) {
>     logger.error('Failed to create user', { userData, error: error.message });
>     throw new ApiError('Invalid user data', 400);
>   }
> };
> ```
> Создай функцию updateUser(userId, userData) в таком же стиле."

### **Пример 2: Архитектурные паттерны**

**Задача:** Реализовать кэширование

**Запрос с Few-Shot:**
> "Добавь кэширование в этот сервис. Вот наши паттерны:
> ```javascript
> // Пример 1: Memory cache
> class MemoryCache {
>   constructor(ttl = 300000) { // 5 минут
>     this.cache = new Map();
>     this.ttl = ttl;
>   }
>   
>   set(key, value) {
>     this.cache.set(key, {
>       value,
>       expires: Date.now() + this.ttl
>     });
>   }
>   
>   get(key) {
>     const item = this.cache.get(key);
>     if (!item || Date.now() > item.expires) {
>       this.cache.delete(key);
>       return null;
>     }
>     return item.value;
>   }
> }
> 
> // Пример 2: Cache decorator
> const cached = (ttl = 300000) => {
>   return (target, propertyKey, descriptor) => {
>     const originalMethod = descriptor.value;
>     const cache = new Map();
>     
>     descriptor.value = async function(...args) {
>       const key = JSON.stringify(args);
>       // ... кэш логика
>     };
>   };
> };
> ```
> Используй похожий подход для кэширования результатов databaseService.getProducts()"

---

## **Заключение главы**

В этой главе мы изучили полный алфавит Vibe-Coding:

1. **Естественный язык** — грамматика смысла против синтаксиса
2. **Семантическая точность** — баланс между требованиями и креативностью  
3. **Few-Shot** — передача паттернов через примеры
4. **Chain of Thought** — осознанное программирование с ИИ

**Ключевые выводы:**
- Vibe-Coding требует нового подхода к коммуникации
- Примеры и структурированные рассуждения мощнее текстовых описаний
- Баланс точности и гибкости — ключ к успеху

В следующей части мы перейдём к практическому применению этих техник в жизненном цикле запроса.

